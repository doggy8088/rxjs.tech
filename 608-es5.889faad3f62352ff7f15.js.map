{"version":3,"mappings":"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","names":["e","_","constructor","n","getDecisionTree$","this","http","get","ɵfac","t","factory","a","error","O","previousBranchIds","currentBranchId","Z","initialState","dataService","pipe","B","o","y","C","x","tree$","state$","l","v","_slicedToArray","h","_ref4","includes","length","c","map","s","label","join","trim","_ref6","options","u","initial","_ref9","$","getValue","selectOption","next","snapShot","back","slice","startOver","A","transform","pure","Y","operatorDecisionTreeService","currentSentence$","options$","isBeyondInitialQuestion$","hasError$","scrollService","scrollToTop","ngOnDestroy","selectors","j","T","imports","p","m","d","f"],"sources":["webpack:///src/app/custom-elements/operator-decision-tree/operator-decision-tree-data.service.ts","webpack:///src/app/custom-elements/operator-decision-tree/utils.ts","webpack:///src/app/custom-elements/operator-decision-tree/operator-decision-tree.service.ts","webpack:///src/app/custom-elements/operator-decision-tree/doc-type-name.pipe.ts","webpack:///src/app/custom-elements/operator-decision-tree/operator-decision-tree.component.html","webpack:///src/app/custom-elements/operator-decision-tree/operator-decision-tree.component.ts","webpack:///src/app/custom-elements/operator-decision-tree/operator-decision-tree.module.ts"],"sourcesContent":["import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OperatorDecisionTree } from './interfaces';\n\n@Injectable()\nexport class OperatorDecisionTreeDataService {\n  constructor(private http: HttpClient) {}\n\n  getDecisionTree$(): Observable<OperatorDecisionTree> {\n    return this.http.get<OperatorDecisionTree>(\n      '/generated/docs/app/decision-tree-data.json'\n    );\n  }\n}\n","import { OperatorTreeNodeWithOptions } from './interfaces';\n\nexport function isInitialDecision(previousBranchIds: string[]): boolean {\n  return (\n    previousBranchIds.includes('initial') && previousBranchIds.length === 1\n  );\n}\n\nexport function treeIsErrorFree(tree): boolean {\n  return !tree.error;\n}\n\nexport function nodeHasOptions(node): node is OperatorTreeNodeWithOptions {\n  return !!node.options;\n}\n","import { Injectable } from '@angular/core';\nimport { BehaviorSubject, combineLatest, Observable, of } from 'rxjs';\nimport { catchError, filter, map, mapTo, shareReplay } from 'rxjs/operators';\nimport { OperatorDecisionTree, OperatorTreeNode, State } from './interfaces';\nimport { OperatorDecisionTreeDataService } from './operator-decision-tree-data.service';\nimport { isInitialDecision, nodeHasOptions, treeIsErrorFree } from './utils';\n\n@Injectable()\nexport class OperatorDecisionTreeService {\n  private initialState: State = {\n    previousBranchIds: ['initial'],\n    currentBranchId: 'initial'\n  };\n  private state$ = new BehaviorSubject<State>(this.initialState);\n  private tree$: Observable<\n    OperatorDecisionTree\n  > = this.dataService.getDecisionTree$().pipe(\n    catchError(error => of(error)), // This helps if the JSON for some reason fails to get fetched\n    shareReplay()\n  );\n\n  currentSentence$: Observable<string> = combineLatest(\n    this.tree$,\n    this.state$\n  ).pipe(\n    filter(([tree]) => treeIsErrorFree(tree)),\n    map(([tree, { previousBranchIds }]) =>\n        isInitialDecision(previousBranchIds)\n            ? '從下表中選擇一個選項，以開始決策'\n            : `${previousBranchIds\n                .map(entityId => {\n                  return tree[entityId].label;\n                })\n                .join(' ')}...`.trim()\n    )\n  );\n\n  options$: Observable<(OperatorTreeNode)[]> = combineLatest(\n    this.tree$,\n    this.state$\n  ).pipe(\n    filter(([tree, state]) => {\n      return (\n        treeIsErrorFree(tree) &&\n        !!tree[state.currentBranchId] &&\n        !!tree[state.currentBranchId].options\n      );\n    }),\n    map(([tree, state]) => {\n      // Project is currently using TypeScript 2.9.2\n      // With TS 3.1+ this can be done better if we map to [tree, node] and typeguard with a tuple in a filter\n      // filter((a): a is [OperatorDecisionTree, OperatorTreeNodeWithOptions] => !a[0].error && !!a[1].options)\n      const node = tree[state.currentBranchId];\n      return nodeHasOptions(node)\n        ? node.options.map(option => tree[option])\n        : tree['initial'].options.map(option => tree[option]);\n    })\n  );\n\n  isBeyondInitialQuestion$: Observable<boolean> = this.state$.pipe(\n    map(({ currentBranchId }) => currentBranchId !== 'initial')\n  );\n\n  // This helps if the JSON for some reason fails to get fetched\n  hasError$ = this.tree$.pipe(\n    filter(tree => !!tree.error),\n    mapTo(true)\n  );\n\n  constructor(private dataService: OperatorDecisionTreeDataService) {}\n\n  private get snapShot(): State {\n    return this.state$.getValue();\n  }\n\n  selectOption(optionId: string): void {\n    this.state$.next({\n      previousBranchIds: [...this.snapShot.previousBranchIds, optionId],\n      currentBranchId: optionId\n    });\n  }\n\n  back(): void {\n    const previousOptionId = this.snapShot.previousBranchIds[\n      this.snapShot.previousBranchIds.length - 2\n    ];\n\n    if (previousOptionId) {\n      this.state$.next({\n        previousBranchIds: [\n          ...this.snapShot.previousBranchIds.slice(\n            0,\n            this.snapShot.previousBranchIds.length - 1\n          )\n        ],\n        currentBranchId: previousOptionId\n      });\n    }\n  }\n\n  startOver(): void {\n    this.state$.next(this.initialState);\n  }\n}\n","import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'docTypeName',\n})\nexport class DocTypeNamePipe implements PipeTransform {\n\n  transform(value: string): string {\n    switch (value) {\n      case 'class':\n        return '類';\n      case 'function':\n        return '函式';\n      default:\n        return value;\n    }\n  }\n\n}\n","<h1 class=\"mat-heading\" tabindex=\"0\">\n  運算子決策樹\n</h1>\n<ng-container *ngIf=\"!(hasError$ | async); else hasErrorTemplate\">\n  <h2 class=\"mat-subheading-2\" tabindex=\"0\">\n    {{currentSentence$ | async}}\n  </h2>\n  <ng-container *ngIf=\"isBeyondInitialQuestion$ | async\">\n    <section>\n      <button\n              (click)=\"back()\"\n              mat-button\n              class=\"back\"\n      >後退\n      </button>\n      <button\n              (click)=\"startOver()\"\n              mat-button\n              color=\"warn\"\n              class=\"start-over\"\n      >重新開始\n      </button>\n    </section>\n  </ng-container>\n  <div>\n    <ng-container *ngFor=\"let option of options$ | async\">\n      <ng-container *ngIf=\"option.options; else operatorTempalte\">\n        <button\n                class=\"option mat-body-1\"\n                (click)=\"selectOption(option.id, $event)\"\n                [@flyIn]\n        >\n          <mat-card matRipple>\n            {{option.label}}\n          </mat-card>\n        </button>\n      </ng-container>\n      <ng-template #operatorTempalte>\n        <p *ngIf=\"option.method\" class=\"mat-body-1\">\n          你需要\n          <a href=\"{{option.path}}#{{option.method}}\">{{option.label}}</a>  {{option.docType|docTypeName}}\n          中的 {{option.method}} 方法。\n        </p>\n        <p *ngIf=\"!option.method\" class=\"mat-body-1\">\n          你需要\n          <a href=\"{{option.path}}\">{{option.label}} {{option.docType | docTypeName}}</a>。\n        </p>\n      </ng-template>\n    </ng-container>\n  </div>\n</ng-container>\n\n<ng-template #hasErrorTemplate>\n  <div class=\"mat-body-1 error\">\n    <p translation-result=\"on\">啊哦！載入決策樹時出了點問題……非常抱歉。請嘗試重新整理本頁面。</p>\n    <p translation-origin=\"off\">Oops! There was an issue loading the decision tree.. we're real sorry about that. Please\n      try reloading the page.</p>\n    <p translation-result=\"on\">你還可以試試<a href=\"https://github.com/ReactiveX/rxjs/issues/new?template=documentation.md\"\n                                        target=\"_blank\">在 Github\n      送出一個 Issue</a>。</p>\n    <p translation-origin=\"off\">You can also try <a\n            href=\"https://github.com/ReactiveX/rxjs/issues/new?template=documentation.md\" target=\"_blank\">submitting an\n      issue on Github</a>.</p>\n  </div>\n</ng-template>\n","import {\n  animate,\n  state,\n  style,\n  transition,\n  trigger\n} from '@angular/animations';\nimport { Component, OnDestroy } from '@angular/core';\nimport { ScrollService } from 'app/shared/scroll.service';\nimport { Observable } from 'rxjs';\nimport { OperatorTreeNode } from './interfaces';\nimport { OperatorDecisionTreeService } from './operator-decision-tree.service';\n\n@Component({\n  selector: 'aio-operator-decision-tree',\n  templateUrl: './operator-decision-tree.component.html',\n  styleUrls: ['./operator-decision-tree.component.scss'],\n  animations: [\n    trigger('flyIn', [\n      state('in', style({ transform: 'translateX(0)' })),\n      transition(':enter', [\n        style({ transform: 'translateX(-100%)' }),\n        animate(250)\n      ])\n    ])\n  ]\n})\nexport class OperatorDecisionTreeComponent implements OnDestroy {\n  currentSentence$: Observable<string> = this.operatorDecisionTreeService.currentSentence$;\n  options$: Observable<OperatorTreeNode[]> = this.operatorDecisionTreeService.options$;\n  isBeyondInitialQuestion$: Observable<boolean> = this.operatorDecisionTreeService.isBeyondInitialQuestion$;\n  hasError$: Observable<boolean> = this.operatorDecisionTreeService.hasError$;\n\n  constructor(\n    private operatorDecisionTreeService: OperatorDecisionTreeService,\n    private scrollService: ScrollService\n  ) {}\n\n  selectOption(optionId: string): void {\n    this.operatorDecisionTreeService.selectOption(optionId);\n    this.scrollService.scrollToTop();\n  }\n\n  back(): void {\n    this.operatorDecisionTreeService.back();\n  }\n\n  startOver(): void {\n    this.operatorDecisionTreeService.startOver();\n  }\n\n  ngOnDestroy(): void {\n    this.startOver();\n  }\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule, Type } from '@angular/core';\nimport { MatButtonModule } from '@angular/material/button';\nimport { MatCardModule } from '@angular/material/card';\nimport { MatRippleModule } from '@angular/material/core';\nimport { ScrollService } from 'app/shared/scroll.service';\nimport { WithCustomElementComponent } from '../element-registry';\nimport { DocTypeNamePipe } from './doc-type-name.pipe';\nimport { OperatorDecisionTreeDataService } from './operator-decision-tree-data.service';\nimport { OperatorDecisionTreeComponent } from './operator-decision-tree.component';\nimport { OperatorDecisionTreeService } from './operator-decision-tree.service';\n\n@NgModule({\n  imports: [CommonModule, MatButtonModule, MatCardModule, MatRippleModule],\n  declarations: [\n    DocTypeNamePipe,\n    OperatorDecisionTreeComponent,\n  ],\n  providers: [\n    OperatorDecisionTreeDataService,\n    OperatorDecisionTreeService,\n    ScrollService,\n  ],\n})\nexport class OperatorDecisionTreeModule implements WithCustomElementComponent {\n  customElementComponent: Type<OperatorDecisionTreeComponent> = OperatorDecisionTreeComponent;\n}\n"]}