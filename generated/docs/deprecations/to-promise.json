{
  "id": "deprecations/to-promise",
  "title": "",
  "contents": "\n<div class=\"content\">\n<h1 id=\"conversion-to-promises\" translation-result=\"on\">轉換為 Promise（承諾）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#conversion-to-promises\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"conversion-to-promises\">Conversion to Promises<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#conversion-to-promises\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">Observables 和 Promises 的相似之處在於，隨著時間的推移，這兩個<a href=\"/guide/observable\">集合</a>都可能產生值，但不同之處在於 Observables 可能不產生或產生多個值，而 Promises 在成功解析時只產生一個值。</p><p translation-origin=\"off\">The similarity between Observables and Promises is that both <a href=\"/guide/observable\">collections</a> may produce values over time, but the difference is that Observables may produce none or more than one value, while Promises produce only one value when resolved successfully.</p>\n\n<h1 id=\"issues\" translation-result=\"on\">問題<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#issues\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"issues\">Issues<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#issues\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">出於這個原因，在 RxJS 7 中，Observable 的 <a href=\"/api/index/class/Observable#toPromise\"><code>toPromise()</code></a> 方法的回傳型別已被修復，以更好地反映 Observable 可以產生零個值的事實。這可能對於某些專案是<strong>重大更改</strong>，因為回傳型別已從 <code>Promise&#x3C;T></code> 更改為 <code>Promise&#x3C;T | undefined></code>。</p><p translation-origin=\"off\">For this reason, in RxJS 7, the return type of the Observable's <a href=\"/api/index/class/Observable#toPromise\"><code>toPromise()</code></a>\nmethod has been fixed to better reflect the fact that Observables can yield zero values. This may be a <strong>breaking change</strong> to some projects as the return type was changed from <code>Promise&#x3C;T></code> to <code>Promise&#x3C;T | undefined></code>.</p>\n\n<p translation-result=\"on\">此外，<code>toPromise()</code> 這個方法名無法指出 Promise 將使用什麼發出的值來解決（resolve），因為 Observables 可以隨著時間的推移產生多個值。轉換為 Promise 時，你可能需要選擇要選取的值 - 是抵達的第一個值還是最後一個值。為了解決所有這些問題，我們決定棄用 <code>toPromise()</code>，並引入兩個新的輔助函式來轉換為 Promise。</p><p translation-origin=\"off\">Also, <code>toPromise()</code> method name was never indicating what emitted value a Promise will resolve with because Observables can produce multiple values over time. When converting to a Promise, you might want to choose which value to pick - either the first value that has arrived or the last one. To fix all these issues, we decided to deprecate <code>toPromise()</code>, and to introduce the two new helper functions for conversion to Promises.</p>\n\n<h1 id=\"use-one-of-the-two-new-functions\" translation-result=\"on\">使用兩個新函式之一<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#use-one-of-the-two-new-functions\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"use-one-of-the-two-new-functions\">Use one of the two new functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#use-one-of-the-two-new-functions\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">作為已棄用的 <code>toPromise()</code> 方法的替代品，你應該使用兩個內建靜態轉換函式 <a href=\"api/index/function/firstValueFrom\"><code>firstValueFrom</code></a> 或 <a href=\"api/index/function/lastValueFrom\"><code>lastValueFrom</code></a> 之一。</p><p translation-origin=\"off\">As a replacement to the deprecated <code>toPromise()</code> method, you should use one of the two built in static conversion functions <a href=\"api/index/function/firstValueFrom\"><code>firstValueFrom</code></a> or <a href=\"api/index/function/lastValueFrom\"><code>lastValueFrom</code></a>.</p>\n\n<h2 id=\"lastvaluefrom\"><code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#lastvaluefrom\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-result=\"on\"><code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> 與 <code>toPromise()</code> 幾乎完全相同，這意味著它將使用 Observable 完成時抵達的最後一個值進行解析，但當 Observable 完成時沒有發出單個值時，其行為有所不同。當 Observable 完成但沒有發出值時，<code>toPromise()</code> 將成功解析為 <code>undefined</code>（因此要更改回傳型別），而 <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> 將拒絕 <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a>。因此，<code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> 的回傳型別是 <code>Promise&#x3C;T></code>，就像 RxJS 6 中的 <code>toPromise()</code> 一樣。</p><p translation-origin=\"off\">The <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> is almost exactly the same as <code>toPromise()</code> meaning that it will resolve with the last value that has arrived when the Observable completes, but with the difference in behavior when Observable completes without emitting a single value. When Observable completes without emitting, <code>toPromise()</code> will successfully resolve with <code>undefined</code> (thus the return type change), while the <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> will reject with the <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a>. Thus, the return type of the\n<code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> is <code>Promise&#x3C;T></code>, just like <code>toPromise()</code> had in RxJS 6.</p>\n\n<h3 id=\"example\" translation-result=\"on\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#example\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"example\">Example<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#example\"><i class=\"material-icons\">link</i></a></h3>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>, <a href=\"api/index/function/take\" class=\"code-anchor\">take</a>, <a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nasync function execute() {\n  const source$ = <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>(2000).pipe(<a href=\"api/index/function/take\" class=\"code-anchor\">take</a>(10));\n  const finalNumber = await <a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a>(source$);\n  console.log(`The final number is ${finalNumber}`);\n}\n\nexecute();\n\n// Expected output:\n// \"The final number is 9\"\n</code-example>\n<h2 id=\"firstvaluefrom\"><code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#firstvaluefrom\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-result=\"on\">但是，你可能希望在第一個值抵達時獲取它而不用等待 Observable 完成，因此你可以使用 <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code>。<code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> 將使用從 Observable 發出的第一個值解析 Promise，並將立即退訂以保留資源。如果 Observable 已完成但沒有發出任何值，則 <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> 也會以 <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a> 為引數進行拒絕。</p><p translation-origin=\"off\">However, you might want to take the first value as it arrives without waiting an Observable to complete, thus you can use <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code>. The <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> will resolve a Promise with the first value that was emitted from the Observable and will immediately unsubscribe to retain resources. The <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> will also reject with an <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a> if the Observable completes with no values emitted.</p>\n\n<h3 id=\"example-1\" translation-result=\"on\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#example-1\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"example-1\">Example<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#example-1\"><i class=\"material-icons\">link</i></a></h3>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>, <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nasync function execute() {\n  const source$ = <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>(2000);\n  const firstNumber = await <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a>(source$);\n  console.log(`The <a href=\"api/index/function/first\" class=\"code-anchor\">first</a> number is ${firstNumber}`);\n}\n\nexecute();\n\n// Expected output:\n// \"The <a href=\"api/index/function/first\" class=\"code-anchor\">first</a> number is 0\"\n</code-example>\n<p translation-result=\"on\"><span class=\"informal\">如果來源 Observable 出錯，這兩個函式都會回傳一個拒絕的 Promise。Promise 將以 Observable 錯誤相同的錯誤為引數進行拒絕。</span></p><p translation-origin=\"off\"><span class=\"informal\">Both functions will return a Promise that rejects if the source Observable errors. The Promise will reject with the same error that the Observable has errored with.</span></p>\n\n<h1 id=\"use-default-value\" translation-result=\"on\">使用預設值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#use-default-value\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"use-default-value\">Use default value<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#use-default-value\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">如果你不希望在完成前沒有發出值的情況下 <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> 或 <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> 建立的 Promise 以 <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a> 為引數進行拒絕，則可以使用第二個引數。第二個引數應該是一個帶有 <code>defaultValue</code> 引數的物件。當來源 Observable 完成而沒有發出值時，<code>defaultValue</code> 中的值將用於解析 Promise。</p><p translation-origin=\"off\">If you don't want Promises created by <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> or <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> to reject with <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a> if there were no emissions before completion, you can use the second parameter. The second parameter is expected to be an object with <code>defaultValue</code> parameter. The value in the <code>defaultValue</code> will be used to resolve a Promise when source Observable completes without emitted values.</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a>, <a href=\"api/index/const/EMPTY\" class=\"code-anchor\">EMPTY</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst result = await <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a>(<a href=\"api/index/const/EMPTY\" class=\"code-anchor\">EMPTY</a>, { defaultValue: 0 });\nconsole.log(result);\n\n// Expected output:\n// 0\n</code-example>\n<h1 id=\"warning\" translation-result=\"on\">警告<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#warning\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"warning\">Warning<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#warning\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">僅當你<em>知道</em>Observable 最終會完成時才應該使用 <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> 函式。如果你<em>知道</em> Observable 將發出至少一個值<em>或</em>最終肯定會完成，則應該使用 <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> 函式。如果來源 Observable 沒有完成或發出值，則你最終會得到一個掛起的 Promise，並且可能所有非同步函式的狀態都被掛在記憶體中。為避免這種情況，可以考慮新增 <a href=\"api/index/function/timeout\"><code>timeout</code></a>、<a href=\"api/index/function/take\"><code>take</code></a>、<a href=\"api/index/function/takeWhile\"><code>takeWhile</code></a> 或 <a href=\"api/index/function/takeUntil\"><code>takeUntil</code></a> 等運算子。</p><p translation-origin=\"off\">Only use <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> function if you <em>know</em> an Observable will eventually complete. The <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> function should be used if you <em>know</em> an Observable will emit at least one value <em>or</em> will eventually complete. If the source Observable does not complete or emit, you will end up with a Promise that is hung up, and potentially all of the state of an async function hanging out in memory. To avoid this situation, look into adding something like <a href=\"api/index/function/timeout\"><code>timeout</code></a>, <a href=\"api/index/function/take\"><code>take</code></a>, <a href=\"api/index/function/takeWhile\"><code>takeWhile</code></a>, or\n<a href=\"api/index/function/takeUntil\"><code>takeUntil</code></a> amongst others.</p>\n\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /api/index/class/Observable#toPromise\n - /guide/observable\n - api/index/const/EMPTY\n - api/index/function/first\n - api/index/function/firstValueFrom\n - api/index/function/from\n - api/index/function/interval\n - api/index/function/lastValueFrom\n - api/index/function/take\n - api/index/function/takeUntil\n - api/index/function/takeWhile\n - api/index/function/timeout\n - api/index/interface/EmptyError\n - deprecations/to-promise#conversion-to-promises\n - deprecations/to-promise#example\n - deprecations/to-promise#example-1\n - deprecations/to-promise#firstvaluefrom\n - deprecations/to-promise#issues\n - deprecations/to-promise#lastvaluefrom\n - deprecations/to-promise#use-default-value\n - deprecations/to-promise#use-one-of-the-two-new-functions\n - deprecations/to-promise#warning\n-->"
}