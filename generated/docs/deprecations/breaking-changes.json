{
  "id": "deprecations/breaking-changes",
  "title": "",
  "contents": "\n<div class=\"content\">\n<h1 id=\"breaking-changes-in-version-7\" translation-result=\"on\">版本 7 中的重大更改<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#breaking-changes-in-version-7\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"breaking-changes-in-version-7\">Breaking Changes in Version 7<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#breaking-changes-in-version-7\"><i class=\"material-icons\">link</i></a></h1>\n\n<h2 id=\"general\" translation-result=\"on\">整體更改<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#general\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"general\">General<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#general\"><i class=\"material-icons\">link</i></a></h2>\n\n<ul>\n<li>\n<p translation-result=\"on\"><strong>TS：</strong> RxJS 需要 TS 4.2</p><p translation-origin=\"off\"><strong>TS:</strong> RxJS requires TS 4.2</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>rxjs-compat：</strong> <code>rxjs-compat</code> 未針對 v7 發布</p><p translation-origin=\"off\"><strong>rxjs-compat:</strong> <code>rxjs-compat</code> is not published for v7</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>toPromise：</strong> toPromise 回傳型別在 TypeScript 中是 <code>T | undefined</code>，這是正確的，但可能會破壞某些建立。</p><p translation-origin=\"off\"><strong>toPromise:</strong> toPromise return type now returns <code>T | undefined</code> in TypeScript, which is correct, but may break builds.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>Subscription（訂閱）：</strong> <code>add</code> 不再回傳不必要的訂閱引用。這樣做是為了防止由遺留行為引起的混亂。你現在可以直接使用 <code>add</code> 和 <code>remove</code> 來新增和刪除函式和訂閱，以進行 <code><a href=\"api/index/class/Subscription\" class=\"code-anchor\">Subscription</a></code> 的拆解。在此之前，<code>remove</code> 只能刪除訂閱。</p><p translation-origin=\"off\"><strong>Subscription:</strong> <code>add</code> no longer returns an unnecessary Subscription reference. This was done to prevent confusion caused by a legacy behavior. You can now add and remove functions and Subscriptions as teardowns to and from a <code><a href=\"api/index/class/Subscription\" class=\"code-anchor\">Subscription</a></code> using <code>add</code> and <code>remove</code> directly. Before this, <code>remove</code> only accepted subscriptions.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>Observable（可觀察者）：</strong> <code>lift</code> 不再暴露。<em>從來沒有文件說過</em>函式庫的最終使用者可以使用 <code>lift</code> 建立運算子。Lift 有<a href=\"https://github.com/ReactiveX/rxjs/issues/5431\">各種各樣的問題</a>，並且一直是 rxjs 的內部實現細節，可能在早期最有價值的時候被少數高階使用者使用。<code>lift</code> 的值，最初是 <code><a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code> 的子類別，是由所有實現了 lift 的運算子組合而來的。現實情況是，該功能並未廣為人知、使用或支援，並且從未寫在文件中，因為它在首次新增時是實驗性的。在 v7 結束之前，<code>lift</code> 將保持在 Observable 上。標準 JavaScript 使用者不會注意到任何異常。然而，TypeScript 使用者可能會看到關於 <code>lift</code> 不是 observable 成員的抱怨。要解決此問題，你可以做兩件事： 1.<a href=\"https://rxjs.dev/guide/operators\">按照文件中的說明</a>重寫你的運算子，使它們回傳 <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code>。或 2. 將你的 observable 轉換為 <code>any</code> 並以這種方式訪問 <code>lift</code>\n。如果你不希望在我們遷移到版本 8 時出現問題，建議使用方法 1。</p><p translation-origin=\"off\"><strong>Observable:</strong> <code>lift</code> no longer exposed. It was <em>NEVER</em> documented that end users of the library should be creating operators using <code>lift</code>. Lift has a <a href=\"https://github.com/ReactiveX/rxjs/issues/5431\">variety of issues</a> and was always an internal implementation detail of rxjs that might have been used by a few power users in the early days when it had the most value. The value of <code>lift</code>, originally, was that subclassed <code><a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code>s would compose through all operators that implemented lift. The reality is\nthat feature is not widely known, used, or supported, and it was never documented as it was very experimental when it was first added. Until the end of v7, <code>lift</code> will remain on Observable. Standard JavaScript users will notice no difference. However, TypeScript users might see complaints about <code>lift</code> not being a member of observable. To workaround this issue there are two things you can do: 1. Rewrite your operators as <a href=\"https://rxjs.dev/guide/operators\">outlined in the documentation</a>, such that they\nreturn <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code>. or 2. cast your observable as <code>any</code> and access <code>lift</code> that way. Method 1 is recommended if you do not want things to break when we move to version 8.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>Subscriber（訂閱者）：</strong> <code>new <a href=\"api/index/class/Subscriber\" class=\"code-anchor\">Subscriber</a></code> 不再接受 0-3 個引數。要使用 0-3 個引數建立 <code><a href=\"api/index/class/Subscriber\" class=\"code-anchor\">Subscriber</a></code>，請使用 <code>Subscriber.create</code>。但是，請注意，你幾乎沒有理由直接建立 <code><a href=\"api/index/class/Subscriber\" class=\"code-anchor\">Subscriber</a></code> 的引用，並且 <code>Subscriber.create</code> 和 <code>new <a href=\"api/index/class/Subscriber\" class=\"code-anchor\">Subscriber</a></code> 都已棄用。</p><p translation-origin=\"off\"><strong>Subscriber:</strong> <code>new <a href=\"api/index/class/Subscriber\" class=\"code-anchor\">Subscriber</a></code> no longer takes 0-3 arguments. To create a <code><a href=\"api/index/class/Subscriber\" class=\"code-anchor\">Subscriber</a></code> with 0-3 arguments, use <code>Subscriber.create</code>. However, please note that there is little to no reason that you should be creating <code><a href=\"api/index/class/Subscriber\" class=\"code-anchor\">Subscriber</a></code> references directly, and <code>Subscriber.create</code> and <code>new <a href=\"api/index/class/Subscriber\" class=\"code-anchor\">Subscriber</a></code> are both deprecated.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>onUnhandledError：</strong>當 Observable 的訂閱已經發出了某個出錯或完成通知，在設定此訂閱期間發生的錯誤，現在將丟擲它們自己的呼叫堆疊。就在它要呼叫 <code>console.warn</code> 之前。這可能會破壞 node 應用的某些邊緣情況，可以將其設定為因未處理的異常而終止。萬一這個變更影響到了你，你可以在新的設定項中將此行為設定為 <code>console.warn</code>，如下所示： <code>import { <a href=\"api/index/const/config\" class=\"code-anchor\">config</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs'; config.onUnhandledError = (err) => console.warn(err);</code></p><p translation-origin=\"off\"><strong>onUnhandledError:</strong> Errors that occur during setup of an observable subscription after the subscription has emitted an error or completed will now throw in their own call stack. Before it would call <code>console.warn</code>. This is potentially breaking in edge cases for node applications, which may be configured to terminate for unhandled exceptions. In the unlikely event this affects you, you can configure the behavior to <code>console.warn</code> in the new configuration setting like\nso: <code>import { <a href=\"api/index/const/config\" class=\"code-anchor\">config</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs'; config.onUnhandledError = (err) => console.warn(err);</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>RxJS 錯誤型別</strong>由於現在各種錯誤都有了適當的 <code>stack</code> 屬性，因此基於對這些錯誤的理想化假設而編寫的測試可能會失敗。在某些測試框架中，對兩個錯誤實例的深度相等性檢查將檢查 <code>stack</code> 中的值，這樣它們就不相等了。</p><p translation-origin=\"off\"><strong>RxJS Error types</strong> Tests that are written with naive expectations against errors may fail now that errors have a proper <code>stack</code> property. In some testing frameworks, a deep equality check on two error instances will check the values in <code>stack</code>, which could be different.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">不能再透過 Observer 函式的 <code>this</code> 上下文訪問 <code>unsubscribe</code>。要重新啟用它，請在 <code>import { <a href=\"api/index/const/config\" class=\"code-anchor\">config</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';</code> 處找到的 rxjs <code><a href=\"api/index/const/config\" class=\"code-anchor\">config</a></code> 上設定 <code>config.useDeprecatedNextContext = true</code> ; .請注意，啟用此功能將導致所有消費者訂閱的效能下降。</p><p translation-origin=\"off\"><code>unsubscribe</code> no longer available via the <code>this</code> context of observer functions. To reenable, set <code>config.useDeprecatedNextContext = true</code> on the rxjs <code><a href=\"api/index/const/config\" class=\"code-anchor\">config</a></code> found at <code>import { <a href=\"api/index/const/config\" class=\"code-anchor\">config</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';</code>. Note that enabling this will result in a performance penalty for all consumer subscriptions.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/index/class/Subscriber\" class=\"code-anchor\">Subscriber</a></code> 外漏的實現細節 <code>_unsubscribeAndRecycle</code> 已被刪除。只要使用新的 <code><a href=\"api/index/class/Subscription\" class=\"code-anchor\">Subscription</a></code> 物件就行了</p><p translation-origin=\"off\">Leaked implementation detail <code>_unsubscribeAndRecycle</code> of <code><a href=\"api/index/class/Subscriber\" class=\"code-anchor\">Subscriber</a></code> has been removed. Just use new <code><a href=\"api/index/class/Subscription\" class=\"code-anchor\">Subscription</a></code> objects</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/index/class/VirtualTimeScheduler\" class=\"code-anchor\">VirtualTimeScheduler</a></code> 上的靜態 <code>sortActions</code> 方法在 TS 型別中已經不再對外暴露了。</p><p translation-origin=\"off\">The static <code>sortActions</code> method on <code><a href=\"api/index/class/VirtualTimeScheduler\" class=\"code-anchor\">VirtualTimeScheduler</a></code> is no longer publicly exposed by our TS types.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>Notification.createNext(undefined)</code> 將不再每次都回傳完全相同的引用。</p><p translation-origin=\"off\"><code>Notification.createNext(undefined)</code> will no longer return the exact same reference everytime.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">由於 <code><a href=\"api/index/class/Notification\" class=\"code-anchor\">Notification</a></code> 和 <code><a href=\"api/index/function/dematerialize\" class=\"code-anchor\">dematerialize</a></code> 強化了型別簽名，因此可能會查出一些傳遞給這些運算子的型別無效問題。</p><p translation-origin=\"off\">Type signatures tightened up around <code><a href=\"api/index/class/Notification\" class=\"code-anchor\">Notification</a></code> and <code><a href=\"api/index/function/dematerialize\" class=\"code-anchor\">dematerialize</a></code>, may uncover issues with invalid types passed to those operators.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">已刪除 <code>for await</code> 的實驗性支援。請改用<a href=\"https://github.com/benlesh/rxjs-for-await\">https://github.com/benlesh/rxjs-for-await</a>。</p><p translation-origin=\"off\">Experimental support for <code>for await</code> as been removed. Use <a href=\"https://github.com/benlesh/rxjs-for-await\">https://github.com/benlesh/rxjs-for-await</a> instead.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">當提供了排程器時，<code><a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a></code> 不再排程發出值的過程。如果你需要該行為，請使用 <code><a href=\"api/index/function/pipe\" class=\"code-anchor\">pipe</a></code> 在 <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> 中編寫，例如： <code>new <a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a>(2, 3000).pipe(<a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a>(<a href=\"api/index/const/asap\" class=\"code-anchor\">asap</a>))</code></p><p translation-origin=\"off\"><code><a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a></code> no longer schedules emissions when a scheduler is provided. If you need that behavior, please compose in <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> using <code><a href=\"api/index/function/pipe\" class=\"code-anchor\">pipe</a></code>, for example: <code>new <a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a>(2, 3000).pipe(<a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a>(<a href=\"api/index/const/asap\" class=\"code-anchor\">asap</a>))</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>rxjs-compat：</strong> <code>rxjs/Rx</code> 不再是有效的匯入點。</p><p translation-origin=\"off\"><strong>rxjs-compat:</strong> <code>rxjs/Rx</code> is no longer a valid import site.</p>\n\n</li>\n</ul>\n<h2 id=\"operators\" translation-result=\"on\">運算子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#operators\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"operators\">Operators<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#operators\"><i class=\"material-icons\">link</i></a></h2>\n\n<h3 id=\"concat\" translation-result=\"on\">concat（串聯）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#concat\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"concat\">concat<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#concat\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\"><strong>concat：</strong>泛化簽名已更改。建議不要再顯式傳遞泛型，請使用型別推斷。如果不得不如此，請使用 <code>as</code> 轉換。</p><p translation-origin=\"off\"><strong>concat:</strong> Generic signature changed. Recommend not explicitly passing generics, just let inference do its job. If you must, cast with <code>as</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>of：</strong>泛型簽名已更改，不再指定泛型，請使用型別推斷或使用 <code>as</code> 轉換。</p><p translation-origin=\"off\"><strong>of:</strong> Generic signature changed, do not specify generics, allow them to be inferred or use <code>as</code></p>\n\n</li>\n</ul>\n<h3 id=\"count\" translation-result=\"on\">count（計數）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#count\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"count\">count<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#count\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\"><strong>count：</strong>不能再將 <code>source</code> observable 作為第三個引數傳遞給謂詞。該功能很少使用，並且價值有限。解決方法是：如果你需要在其中訪問它，就簡單地關閉函式內部的源。</p><p translation-origin=\"off\"><strong>count:</strong> No longer passes <code>source</code> observable as a third argument to the predicate. That feature was rarely used, and of limited value. The workaround is to simply close over the source inside of the function if you need to access it in there.</p>\n\n</li>\n</ul>\n<h3 id=\"defer\" translation-result=\"on\">defer（推遲）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#defer\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"defer\">defer<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#defer\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/index/function/defer\" class=\"code-anchor\">defer</a></code> 不再允許工廠回傳 <code>void</code> 或 <code>undefined</code>。所有傳遞給 defer 的工廠都必須回傳一個適當的 <code><a href=\"api/index/type-alias/ObservableInput\" class=\"code-anchor\">ObservableInput</a></code>，例如 <code><a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code>、<code>Promise</code> 等。要獲得與之前相同的行為，請從工廠中 <code>return <a href=\"api/index/const/EMPTY\" class=\"code-anchor\">EMPTY</a></code> 或 <code>return <a href=\"api/index/function/of\" class=\"code-anchor\">of</a>()</code>。</p><p translation-origin=\"off\"><code><a href=\"api/index/function/defer\" class=\"code-anchor\">defer</a></code> no longer allows factories to return <code>void</code> or <code>undefined</code>. All factories passed to defer must return a proper <code><a href=\"api/index/type-alias/ObservableInput\" class=\"code-anchor\">ObservableInput</a></code>, such as <code><a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code>, <code>Promise</code>, et al. To get the same behavior as you may have relied on previously, <code>return <a href=\"api/index/const/EMPTY\" class=\"code-anchor\">EMPTY</a></code> or <code>return <a href=\"api/index/function/of\" class=\"code-anchor\">of</a>()</code> from the factory.</p>\n\n</li>\n</ul>\n<h3 id=\"map\" translation-result=\"on\">map（對映）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#map\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"map\">map<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#map\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\"><strong>map:</strong> <code>thisArg</code> 現在預設為 <code>undefined</code>。<code>MapSubscriber</code> 以前的這種預設設定從來沒有任何意義。這隻會影響使用 <code>function</code> 呼叫 map，並像這樣引用 <code>this</code> 的程式碼： <code>source.pipe(<a href=\"api/index/function/map\" class=\"code-anchor\">map</a>(function () { console.log(this); }))</code>。這樣做沒有任何用處，因此預期的破壞將非常小。如果有的話，那就是我們將吸取教訓不再洩露實現細節。</p><p translation-origin=\"off\"><strong>map:</strong> <code>thisArg</code> will now default to <code>undefined</code>. The previous default of <code>MapSubscriber</code> never made any sense. This will only affect code that calls map with a <code>function</code> and references <code>this</code> like so: <code>source.pipe(<a href=\"api/index/function/map\" class=\"code-anchor\">map</a>(function () { console.log(this); }))</code>. There wasn't anything useful about doing this, so the breakage is expected to be very minimal. If anything we're no longer leaking an implementation detail.</p>\n\n</li>\n</ul>\n<h3 id=\"mergescan\" translation-result=\"on\">mergeScan（合併掃描）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#mergescan\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"mergescan\">mergeScan<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#mergescan\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\"><strong>mergeScan：</strong> <code><a href=\"api/index/function/mergeScan\" class=\"code-anchor\">mergeScan</a></code> 後將不再發出其內部狀態。</p><p translation-origin=\"off\"><strong>mergeScan:</strong> <code><a href=\"api/index/function/mergeScan\" class=\"code-anchor\">mergeScan</a></code> will no longer emit its inner state again upon completion.</p>\n\n</li>\n</ul>\n<h3 id=\"of\">of<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#of\"><i class=\"material-icons\">link</i></a></h3>\n<ul>\n<li>\n<p translation-result=\"on\"><strong>of：</strong>與超過 9 個引數一起使用，其中最後一個引數是 <code><a href=\"api/index/interface/SchedulerLike\" class=\"code-anchor\">SchedulerLike</a></code>，它可能會導致包含 <code><a href=\"api/index/interface/SchedulerLike\" class=\"code-anchor\">SchedulerLike</a></code> 的錯誤型別，即使執行時實現其實並不支援它。開發人員應該改用 <code><a href=\"api/index/function/scheduled\" class=\"code-anchor\">scheduled</a></code> 代替它。</p><p translation-origin=\"off\"><strong>of:</strong> Use with more than 9 arguments, where the last argument is a <code><a href=\"api/index/interface/SchedulerLike\" class=\"code-anchor\">SchedulerLike</a></code> may result in the wrong type which includes the <code><a href=\"api/index/interface/SchedulerLike\" class=\"code-anchor\">SchedulerLike</a></code>, even though the run time implementation does not support that. Developers should be using <code><a href=\"api/index/function/scheduled\" class=\"code-anchor\">scheduled</a></code> instead</p>\n\n</li>\n</ul>\n<h3 id=\"pairs\" translation-result=\"on\">pairs（配對）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#pairs\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"pairs\">pairs<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#pairs\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\"><strong>pairs：</strong>如果 IE 中沒有 <code>Object.entries</code> 的 polyfill，<code><a href=\"api/index/function/pairs\" class=\"code-anchor\">pairs</a></code> 將不再起作用。<code><a href=\"api/index/function/pairs\" class=\"code-anchor\">pairs</a></code> 本身也已棄用，使用者應該只使用 <code><a href=\"api/index/function/from\" class=\"code-anchor\">from</a>(Object.entries(obj))</code>。</p><p translation-origin=\"off\"><strong>pairs:</strong> <code><a href=\"api/index/function/pairs\" class=\"code-anchor\">pairs</a></code> will no longer function in IE without a polyfill for <code>Object.entries</code>. <code><a href=\"api/index/function/pairs\" class=\"code-anchor\">pairs</a></code> itself is also deprecated in favor of users just using <code><a href=\"api/index/function/from\" class=\"code-anchor\">from</a>(Object.entries(obj))</code>.</p>\n\n</li>\n</ul>\n<h3 id=\"race\" translation-result=\"on\">race（競速）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#race\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"race\">race<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#race\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\"><strong>race：</strong>如果所提供的來源在同步模式下出錯或完成，<code><a href=\"api/index/function/race\" class=\"code-anchor\">race</a>()</code> 將不再訂閱後續的 observables。這意味著在極少數情況下，訂閱期間可能發生的副作用將不再發生。</p><p translation-origin=\"off\"><strong>race:</strong> <code><a href=\"api/index/function/race\" class=\"code-anchor\">race</a>()</code> will no longer subscribe to subsequent observables if a provided source synchronously errors or completes. This means side effects that might have occurred during subscription in those rare cases will no longer occur.</p>\n\n</li>\n</ul>\n<h3 id=\"repeat\" translation-result=\"on\">repeat（重複）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#repeat\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"repeat\">repeat<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#repeat\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\">一種未寫在文件中的行為：將負的計數引數傳遞給 <code><a href=\"api/index/function/repeat\" class=\"code-anchor\">repeat</a></code> 將導致 observable 永遠重複。</p><p translation-origin=\"off\">An undocumented behavior where passing a negative count argument to <code><a href=\"api/index/function/repeat\" class=\"code-anchor\">repeat</a></code> would result in an observable that repeats forever.</p>\n\n</li>\n</ul>\n<h3 id=\"retry\" translation-result=\"on\">retry（重試）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#retry\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"retry\">retry<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#retry\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\">刪除了一個未寫在文件中的行為，其中將負計數引數傳遞給 <code><a href=\"api/index/function/retry\" class=\"code-anchor\">retry</a></code> 將導致可觀察到的永遠重複。</p><p translation-origin=\"off\">Removed an undocumented behavior where passing a negative count argument to <code><a href=\"api/index/function/retry\" class=\"code-anchor\">retry</a></code> would result in an observable that repeats forever.</p>\n\n</li>\n</ul>\n<h3 id=\"single\" translation-result=\"on\">single（單值）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#single\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"single\">single<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#single\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\">現在，<code><a href=\"api/index/function/single\" class=\"code-anchor\">single</a></code> 運算子將在傳入的值不存在或與提供的謂詞不對應的情況下丟擲錯誤。丟擲的錯誤型別也已更新，請檢視文件以瞭解更改。</p><p translation-origin=\"off\"><code><a href=\"api/index/function/single\" class=\"code-anchor\">single</a></code> operator will now throw for scenarios where values coming in are either not present, or do not match the provided predicate. Error types have thrown have also been updated, please check documentation for changes.</p>\n\n</li>\n</ul>\n<h3 id=\"skiplast\" translation-result=\"on\">skipLast（跳過最後）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#skiplast\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"skiplast\">skipLast<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#skiplast\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\"><strong>skipLast：</strong>當傳遞一個負數時，<code><a href=\"api/index/function/skipLast\" class=\"code-anchor\">skipLast</a></code> 將不再出錯，而是簡單地回傳源，就好像傳遞了 <code>0</code>。</p><p translation-origin=\"off\"><strong>skipLast:</strong> <code><a href=\"api/index/function/skipLast\" class=\"code-anchor\">skipLast</a></code> will no longer error when passed a negative number, rather it will simply return the source, as though <code>0</code> was passed.</p>\n\n</li>\n</ul>\n<h3 id=\"startwith\" translation-result=\"on\">startWith（以...開始）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#startwith\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"startwith\">startWith<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#startwith\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\"><strong>startWith：</strong>當使用超過 7 個引數和一個排程器進行呼叫時，<code><a href=\"api/index/function/startWith\" class=\"code-anchor\">startWith</a></code> 將回傳不正確的型別。不推薦將排程器傳遞給 startWith</p><p translation-origin=\"off\"><strong>startWith:</strong> <code><a href=\"api/index/function/startWith\" class=\"code-anchor\">startWith</a></code> will return incorrect types when called with more than 7 arguments and a scheduler. Passing scheduler to startWith is deprecated</p>\n\n</li>\n</ul>\n<h3 id=\"take\" translation-result=\"on\">take（取）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#take\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"take\">take<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#take\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/index/function/take\" class=\"code-anchor\">take</a></code> 並且現在將為負數或 NaN 的引數丟擲執行時錯誤，這包括像 <code><a href=\"api/index/function/take\" class=\"code-anchor\">take</a>()</code> 這樣的非 TS 呼叫。</p><p translation-origin=\"off\"><code><a href=\"api/index/function/take\" class=\"code-anchor\">take</a></code> and will now throw runtime error for arguments that are negative or NaN, this includes non-TS calls like <code><a href=\"api/index/function/take\" class=\"code-anchor\">take</a>()</code>.</p>\n\n</li>\n</ul>\n<h3 id=\"takelast\" translation-result=\"on\">takeLast（取末尾）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#takelast\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"takelast\">takeLast<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#takelast\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/index/function/takeLast\" class=\"code-anchor\">takeLast</a></code> 現在有執行時斷言，會為無效引數丟擲 <code>TypeError</code>。不帶引數或使用 <code>NaN</code> 引數呼叫 takeLast 將丟擲 <code>TypeError</code></p><p translation-origin=\"off\"><code><a href=\"api/index/function/takeLast\" class=\"code-anchor\">takeLast</a></code> now has runtime assertions that throw <code>TypeError</code>s for invalid arguments. Calling takeLast without arguments or with an argument that is <code>NaN</code> will throw a <code>TypeError</code></p>\n\n</li>\n</ul>\n<h3 id=\"throwerror\" translation-result=\"on\">throwError（丟擲錯誤）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#throwerror\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"throwerror\">throwError<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#throwerror\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\"><strong>throwError：</strong>在一種極端罕見的用法下，<code><a href=\"api/index/function/throwError\" class=\"code-anchor\">throwError</a></code> 不再直接將函式作為錯誤發出。如果你需要將函式作為錯誤推送，則必須使用工廠函式來回傳函式，如下所示： <code><a href=\"api/index/function/throwError\" class=\"code-anchor\">throwError</a>(() => functionToEmit)</code>，換句話說 <code><a href=\"api/index/function/throwError\" class=\"code-anchor\">throwError</a>(() => () => console.log('called later'))</code>。</p><p translation-origin=\"off\"><strong>throwError:</strong> In an extreme corner case for usage, <code><a href=\"api/index/function/throwError\" class=\"code-anchor\">throwError</a></code> is no longer able to emit a function as an error directly. If you need to push a function as an error, you will have to use the factory function to return the function like so: <code><a href=\"api/index/function/throwError\" class=\"code-anchor\">throwError</a>(() => functionToEmit)</code>, in other words <code><a href=\"api/index/function/throwError\" class=\"code-anchor\">throwError</a>(() => () => console.log('called later'))</code>.</p>\n\n</li>\n</ul>\n<h3 id=\"timestamp\" translation-result=\"on\">timestamp（時間戳）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#timestamp\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"timestamp\">timestamp<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#timestamp\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/index/function/timestamp\" class=\"code-anchor\">timestamp</a></code> 運算子接受 <code><a href=\"api/index/interface/TimestampProvider\" class=\"code-anchor\">TimestampProvider</a></code>，它是一個具有回傳數字的 <code>now</code> 方法的任意物件。這意味著為使用 <code><a href=\"api/index/function/timestamp\" class=\"code-anchor\">timestamp</a></code> 運算子只需引入更少的程式碼。這可能會導致 <code><a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a></code> 執行模式出現問題。（請參閱<a href=\"https://github.com/ReactiveX/rxjs/issues/5553\">此處的問題</a>）</p><p translation-origin=\"off\"><code><a href=\"api/index/function/timestamp\" class=\"code-anchor\">timestamp</a></code> operator accepts a <code><a href=\"api/index/interface/TimestampProvider\" class=\"code-anchor\">TimestampProvider</a></code>, which is any object with a <code>now</code> method that returns a number. This means pulling in less code for the use of the <code><a href=\"api/index/function/timestamp\" class=\"code-anchor\">timestamp</a></code> operator. This may cause issues with <code><a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a></code> run mode. (see <a href=\"https://github.com/ReactiveX/rxjs/issues/5553\">Issue here</a>)</p>\n\n</li>\n</ul>\n<h3 id=\"zip\" translation-result=\"on\">zip（拉合）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#zip\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"zip\">zip<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#zip\"><i class=\"material-icons\">link</i></a></h3>\n\n<ul>\n<li>\n<p translation-result=\"on\"><strong>zip：</strong>拉合傳入單個陣列現在會有不同的結果。這是一個極端罕見的情況，因為任何人都不太可能想要把一個陣列和『什麼都沒有』拉合在一起。解決方法是將陣列包裝在另一個陣列 <code><a href=\"api/index/function/zip\" class=\"code-anchor\">zip</a>([[1,2,3]])</code> 中。但這同樣很怪異。</p><p translation-origin=\"off\"><strong>zip:</strong> Zipping a single array will now have a different result. This is an extreme corner-case, because it is very unlikely that anyone would want to zip an array with nothing at all. The workaround would be to wrap the array in another array <code><a href=\"api/index/function/zip\" class=\"code-anchor\">zip</a>([[1,2,3]])</code>. But again, that's pretty weird.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>zip：</strong> <code><a href=\"api/index/function/zip\" class=\"code-anchor\">zip</a></code> 運算子將不再『根據需要』迭代所提供的可迭代物件，而是將可迭代物件視為推送流，就像它們在 RxJS 中的其它任何地方一樣。這意味著傳遞一個無限迭代將導致執行緒死鎖，因為它將不斷地嘗試從該迭代中讀取。這是為了讓我們與所有其它 Rx 實現保持一致。要解決此問題，最好使用 <code><a href=\"api/index/function/map\" class=\"code-anchor\">map</a></code> 或 <code><a href=\"api/index/function/map\" class=\"code-anchor\">map</a></code> 和 <code><a href=\"api/index/function/zip\" class=\"code-anchor\">zip</a></code> 的某種組合。例如，<code><a href=\"api/index/function/zip\" class=\"code-anchor\">zip</a>(source$, iterator)</code> 可以是 <code>source$.pipe(<a href=\"api/index/function/map\" class=\"code-anchor\">map</a>(value => [value, iterator.next().value]))</code>。</p><p translation-origin=\"off\"><strong>zip:</strong> <code><a href=\"api/index/function/zip\" class=\"code-anchor\">zip</a></code> operators will no longer iterate provided iterables \"as needed\", instead the iterables will be treated as push-streams just like they would be everywhere else in RxJS. This means that passing an endless iterable will result in the thread locking up, as it will endlessly try to read from that iterable. This puts us in-line with all other Rx implementations. To work around this, it is probably best to use <code><a href=\"api/index/function/map\" class=\"code-anchor\">map</a></code> or some combination of <code><a href=\"api/index/function/map\" class=\"code-anchor\">map</a></code> and <code><a href=\"api/index/function/zip\" class=\"code-anchor\">zip</a></code>. For example, <code><a href=\"api/index/function/zip\" class=\"code-anchor\">zip</a>(source$, iterator)</code>\ncould be <code>source$.pipe(<a href=\"api/index/function/map\" class=\"code-anchor\">map</a>(value => [value, iterator.next().value]))</code>.</p>\n\n</li>\n</ul>\n<h2 id=\"ajax\">ajax<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/breaking-changes#ajax\"><i class=\"material-icons\">link</i></a></h2>\n<ul>\n<li>\n<p translation-result=\"on\"><code>ajax</code> 正文的序列化現在將在所有情況下使用預設的 XHR 行為。如果主體是 <code>Blob</code>、<code>ArrayBuffer</code>、任何陣列緩衝區檢視（如位元組序列，例如 <code>Uint8Array</code> 等）、<code>FormData</code>、<code>URLSearchParams</code>、<code>string</code> 或 <code>ReadableStream</code>，則使用預設處理。如果 <code>body</code> 是 <code>typeof</code> <code>\"object\"</code> 的，那麼它將透過 <code>JSON.stringify</code> 轉換為 JSON，並且 <code>Content-Type</code> 標頭將設定為 <code>application/json;charset=utf-8</code>。所有其它型別都會發出錯誤。</p><p translation-origin=\"off\"><code>ajax</code> body serialization will now use default XHR behavior in all cases. If the body is a <code>Blob</code>, <code>ArrayBuffer</code>, any array buffer view (like a byte sequence, e.g. <code>Uint8Array</code>, etc), <code>FormData</code>, <code>URLSearchParams</code>, <code>string</code>, or <code>ReadableStream</code>, default handling is use. If the <code>body</code> is otherwise <code>typeof</code> <code>\"object\"</code>, then it will be converted to JSON via <code>JSON.stringify</code>, and the <code>Content-Type</code> header will be set to <code>application/json;charset=utf-8</code>. All other types will emit an error.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">傳遞給 <code>ajax</code> 設定的 <code>Content-Type</code> 標頭不再對 AJAX 請求的序列化行為產生任何影響。</p><p translation-origin=\"off\">The <code>Content-Type</code> header passed to <code>ajax</code> configuration no longer has any effect on the serialization behavior of the AJAX request.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">對於 TypeScript 使用者，<code><a href=\"api/ajax/AjaxRequest\" class=\"code-anchor\">AjaxRequest</a></code> 不能再作為顯式建立 <code>ajax</code> 的型別。現在要改用 <code><a href=\"api/ajax/AjaxConfig\" class=\"code-anchor\">AjaxConfig</a></code>，雖然這兩種型別是相容的，但只有 <code><a href=\"api/ajax/AjaxConfig\" class=\"code-anchor\">AjaxConfig</a></code> 有 <code>progressSubscriber</code> 和 <code>createXHR</code>。</p><p translation-origin=\"off\">For TypeScript users, <code><a href=\"api/ajax/AjaxRequest\" class=\"code-anchor\">AjaxRequest</a></code> is no longer the type that should be explicitly used to create an <code>ajax</code>. It is now <code><a href=\"api/ajax/AjaxConfig\" class=\"code-anchor\">AjaxConfig</a></code>, although the two types are compatible, only <code><a href=\"api/ajax/AjaxConfig\" class=\"code-anchor\">AjaxConfig</a></code> has <code>progressSubscriber</code> and <code>createXHR</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>ajax：</strong>在某種極端罕見的情況下...如果我們在 IE 中發生錯誤，responseType 是 <code>\"json\"</code>，並且 <code>responseType</code> 不是有效的 JSON，則 <code>ajax</code> observable 將不再發出語法錯誤，而是發出帶有更多詳細訊息的完整 <code><a href=\"api/ajax/AjaxError\" class=\"code-anchor\">AjaxError</a></code>。</p><p translation-origin=\"off\"><strong>ajax:</strong> In an extreme corner-case... If an error occurs, the responseType is <code>\"json\"</code>, we're in IE, and the <code>responseType</code> is not valid JSON, the <code>ajax</code> observable will no longer emit a syntax error, rather it will emit a full <code><a href=\"api/ajax/AjaxError\" class=\"code-anchor\">AjaxError</a></code> with more details.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>ajax：</strong> Ajax 實現放棄了對 IE10 及更低版本的支援。這使我們與其它實現保持一致，並有助於清理該區域的程式碼</p><p translation-origin=\"off\"><strong>ajax:</strong> Ajax implementation drops support for IE10 and lower. This puts us in-line with other implementations and helps clean up code in this area</p>\n\n</li>\n</ul>\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/ajax/AjaxConfig\n - api/ajax/AjaxError\n - api/ajax/AjaxRequest\n - api/index/class/Notification\n - api/index/class/Observable\n - api/index/class/ReplaySubject\n - api/index/class/Subscriber\n - api/index/class/Subscription\n - api/index/class/VirtualTimeScheduler\n - api/index/const/EMPTY\n - api/index/const/asap\n - api/index/const/config\n - api/index/function/defer\n - api/index/function/dematerialize\n - api/index/function/from\n - api/index/function/map\n - api/index/function/mergeScan\n - api/index/function/observeOn\n - api/index/function/of\n - api/index/function/pairs\n - api/index/function/pipe\n - api/index/function/race\n - api/index/function/repeat\n - api/index/function/retry\n - api/index/function/scheduled\n - api/index/function/single\n - api/index/function/skipLast\n - api/index/function/startWith\n - api/index/function/take\n - api/index/function/takeLast\n - api/index/function/throwError\n - api/index/function/timestamp\n - api/index/function/zip\n - api/index/interface/SchedulerLike\n - api/index/interface/TimestampProvider\n - api/index/type-alias/ObservableInput\n - api/testing/TestScheduler\n - deprecations/breaking-changes#ajax\n - deprecations/breaking-changes#breaking-changes-in-version-7\n - deprecations/breaking-changes#concat\n - deprecations/breaking-changes#count\n - deprecations/breaking-changes#defer\n - deprecations/breaking-changes#general\n - deprecations/breaking-changes#map\n - deprecations/breaking-changes#mergescan\n - deprecations/breaking-changes#of\n - deprecations/breaking-changes#operators\n - deprecations/breaking-changes#pairs\n - deprecations/breaking-changes#race\n - deprecations/breaking-changes#repeat\n - deprecations/breaking-changes#retry\n - deprecations/breaking-changes#single\n - deprecations/breaking-changes#skiplast\n - deprecations/breaking-changes#startwith\n - deprecations/breaking-changes#take\n - deprecations/breaking-changes#takelast\n - deprecations/breaking-changes#throwerror\n - deprecations/breaking-changes#timestamp\n - deprecations/breaking-changes#zip\n - https://github.com/ReactiveX/rxjs/issues/5431\n - https://github.com/ReactiveX/rxjs/issues/5553\n - https://github.com/benlesh/rxjs-for-await\n - https://rxjs.dev/guide/operators\n-->"
}