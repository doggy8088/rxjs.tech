{
  "id": "guide/core-semantics",
  "title": "",
  "contents": "\n<div class=\"content\">\n<h1 id=\"rxjs-core-semantics\" translation-result=\"on\">RxJS 核心語義<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#rxjs-core-semantics\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"rxjs-core-semantics\">RxJS Core Semantics<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#rxjs-core-semantics\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">從版本 8 開始，核心庫中提供的所有 RxJS 運算子必須滿足以下語義。在當前版本 7 中，所有運算子都應該滿足以下語義（作為準則）。如果沒有，我們需要在<a href=\"https://github.com/ReactiveX/rxjs/issues\">GitHub 上</a>跟蹤問題。</p><p translation-origin=\"off\">Starting in version 8, all RxJS operators that are provided in the core library MUST meet the following semantics. In the current version, version 7, all operators SHOULD meet the following semantics (as guidelines). If they do not, we need to track the issue on <a href=\"https://github.com/ReactiveX/rxjs/issues\">GitHub</a>.</p>\n\n<h2 id=\"purpose\" translation-result=\"on\">目的<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#purpose\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"purpose\">Purpose<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#purpose\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">這些語義的目的是為我們函式庫的使用者提供可預測的行為，並確保我們的許多不同運算子之間的行為一致。應該注意的是，在撰寫本文時，我們並不總是遵守這些語義準則。本文件將作為即將發生的更改的目標，並儘可能地幫我們描述此函式庫。這也是一份『活檔案』，可能會發生變化。</p><p translation-origin=\"off\">The purpose of these semantics is provide predictable behavior for the users of our library, and to ensure consistent behavior between our many different operators. It should be noted that at the time of this writing, we don't always adhere to these semantic guidelines. This document is to serve as a goalpost for upcoming changes and work as much as it is to help describe the library. This is also a \"living document\" and is subject to change.</p>\n\n<h2 id=\"general-design-guidelines\" translation-result=\"on\">一般設計指南<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#general-design-guidelines\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"general-design-guidelines\">General Design Guidelines<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#general-design-guidelines\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><strong>運算子、建構式函式和建立函式等函式在有多個引數的情況下應使用命名引數，並且第一個引數之後的引數往往不夠明顯。</strong> 應簡化主要用例，使其無需設定即可工作。例如，<code>fakeFlattenMap(n => <a href=\"api/index/function/of\" class=\"code-anchor\">of</a>(n))</code> 很好，但 <code>fakeFlattenMap(n => <a href=\"api/index/function/of\" class=\"code-anchor\">of</a>(n), 1)</code> 的可讀性不如 <code>fakeFlattenMap(n => <a href=\"api/index/function/of\" class=\"code-anchor\">of</a>(n), { maxConcurrent: 1 })</code>。其它的東西，比如 <code><a href=\"api/index/function/of\" class=\"code-anchor\">of</a>(1, 2, 3)</code> 很明顯，命名引數沒有意義。</p><p translation-origin=\"off\"><strong>Functions such as operators, constructors, and creation functions, should use named parameters in cases where there is more than 1 argument, and arguments after the first are non-obvious.</strong> The primary use case should be streamlined to work without configuration. For example, <code>fakeFlattenMap(n => <a href=\"api/index/function/of\" class=\"code-anchor\">of</a>(n))</code> is fine, but <code>fakeFlattenMap(n => <a href=\"api/index/function/of\" class=\"code-anchor\">of</a>(n), 1)</code> is less readable than <code>fakeFlattenMap(n => <a href=\"api/index/function/of\" class=\"code-anchor\">of</a>(n), { maxConcurrent: 1 })</code>. Other things, like <code><a href=\"api/index/function/of\" class=\"code-anchor\">of</a>(1, 2, 3)</code> are obvious enough that named parameters don't make\nsense.</p>\n\n<h2 id=\"operators\" translation-result=\"on\">運算子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#operators\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"operators\">Operators<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#operators\"><i class=\"material-icons\">link</i></a></h2>\n\n<ul>\n<li>\n<p translation-result=\"on\">必須是回傳<a href=\"https://rxjs.dev/api/index/interface/OperatorFunction\">運算子函式的函式</a>。也就是 <code>(source: <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>&#x3C;In>) => <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>&#x3C;Out></code>。</p><p translation-origin=\"off\">MUST be a function that returns an <a href=\"https://rxjs.dev/api/index/interface/OperatorFunction\">operator function</a>. That is <code>(source: <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>&#x3C;In>) => <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>&#x3C;Out></code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">回傳的運算子函式必須是<a href=\"https://en.wikipedia.org/wiki/Referential_transparency\">引用透明</a>的。也就是說，如果你要捕獲運算子的回傳值（例如 <code>const double => <a href=\"api/index/function/map\" class=\"code-anchor\">map</a>(x => x + x)</code>），你可以使用該值對任意多個 observables 進行任意操作，而無需更改任何底層運算子引用中的狀態。（例如 <code>a$.pipe(double)</code> 和 <code>b$.pipe(double)</code>）。</p><p translation-origin=\"off\">The returned operator function MUST be <a href=\"https://en.wikipedia.org/wiki/Referential_transparency\">referentially transparent</a>. That is to say, that if you capture the return value of the operator (e.g. <code>const double => <a href=\"api/index/function/map\" class=\"code-anchor\">map</a>(x => x + x)</code>), you can use that value to operate on any many observables as you like without changing any underlying state in the operator reference. (e.g. <code>a$.pipe(double)</code> and <code>b$.pipe(double)</code>).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">操作函式回傳的 observable 必須訂閱到源。</p><p translation-origin=\"off\">The observable returned by the operator function MUST subscribe to the source.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果運算子所執行的操作可以表明它不會改變源輸出的任何內容，則它必須回傳對來源的引用。例如 <code><a href=\"api/index/function/take\" class=\"code-anchor\">take</a>(Infinity)</code> 或 <code><a href=\"api/index/function/skip\" class=\"code-anchor\">skip</a>(0)</code>。</p><p translation-origin=\"off\">If the operation performed by the operator can tell it not change anything about the output of the source, it MUST return the reference to the source. For example <code><a href=\"api/index/function/take\" class=\"code-anchor\">take</a>(Infinity)</code> or <code><a href=\"api/index/function/skip\" class=\"code-anchor\">skip</a>(0)</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">接受『通知者』的運算子，即另一個用於觸發某些行為的可觀察源，必須接受可以透過 <code><a href=\"api/index/function/from\" class=\"code-anchor\">from</a></code> 轉換為 <code><a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code> 的任何型別。例如 <code><a href=\"api/index/function/takeUntil\" class=\"code-anchor\">takeUntil</a></code>。</p><p translation-origin=\"off\">Operators that accept a \"notifier\", that is another observable source that is used to trigger some behavior, must accept any type that can be converted to an <code><a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code> with <code><a href=\"api/index/function/from\" class=\"code-anchor\">from</a></code>. For example <code><a href=\"api/index/function/takeUntil\" class=\"code-anchor\">takeUntil</a></code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">接受『通知器』（如上所述）的運算子只能將來自通知器的下一個值看做『通知』。已發出完成事件的通知器不能用作通知源。</p><p translation-origin=\"off\">Operators that accept \"notifiers\" (as described above), MUST ONLY recognized next values from the notifier as \"notifications\". Emitted completions may not be used a source of notification.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">直接提供給運算子的『通知器』必須在訂閱源<em>之前</em>訂閱。透過提供給運算子的工廠函式建立的『通知器』應該儘早訂閱。</p><p translation-origin=\"off\">\"Notifiers\" provided directly to the operator MUST be subscribed to <em>before</em> the source is subscribed to. \"Notifiers\" created via factory function provided to the operator SHOULD be subscribed to at the earliest possible moment.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">運算子函式回傳的 observable 應該視為源的『消費者』。因此，消費者必須在知道不再需要值後立即退訂源，然後再繼續執行<em>任意</em>操作。</p><p translation-origin=\"off\">The observable returned by the operator function is considered to be the \"consumer\" of the source. As such, the consumer MUST unsubscribe from the source as soon as it knows it no longer needs values before proceeding to do <em>any</em> action.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在源完成後發生的事件應該在源已經終結(finalize)之後發生。這是為了確保終結程式碼始終發生在與事件相關的可預測時間範圍內。</p><p translation-origin=\"off\">Events that happen after the completion of a source SHOULD happen after the source finalizes. This is to ensure that finalization always happens in a predictable time frame relative to the event.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>Error</code> 物件的保留時間不得超過必要的時間。這可能是記憶體壓力的來源。</p><p translation-origin=\"off\"><code>Error</code> objects MUST NOT be retained longer than necessary. This is a possible source of memory pressure.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>Promise</code> 引用的保留時間不得超過必要的時間。這可能是記憶體壓力的來源。</p><p translation-origin=\"off\"><code>Promise</code> references MUST NOT be retained longer than necessary. This is a possible source of memory pressure.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果他們對建立函式執行相關操作，他們應該只使用字尾 <code>With</code> 來共享建立函式的名稱。（例如 <code><a href=\"api/index/function/concat\" class=\"code-anchor\">concat</a></code> 和 <code><a href=\"api/index/function/concatWith\" class=\"code-anchor\">concatWith</a></code>）。</p><p translation-origin=\"off\">IF they perform a related operation to a creation function, they SHOULD share the creation function's name only with the suffix <code>With</code>. (e.g. <code><a href=\"api/index/function/concat\" class=\"code-anchor\">concat</a></code> and <code><a href=\"api/index/function/concatWith\" class=\"code-anchor\">concatWith</a></code>).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">不應該有『結果選擇器』。這是一個輔助引數，它提供了在執行運算子的主要操作之後『對映』值的能力。</p><p translation-origin=\"off\">SHOULD NOT have \"result selectors\". This is a secondary argument that provides the ability to \"map\" values after performing the primary operation of the operator.</p>\n\n</li>\n</ul>\n<h2 id=\"creation-functions\" translation-result=\"on\">建立函式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#creation-functions\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"creation-functions\">Creation Functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/core-semantics#creation-functions\"><i class=\"material-icons\">link</i></a></h2>\n\n<ul>\n<li>\n<p translation-result=\"on\">名稱不得以 <code>With</code> 結尾。這是為建立函式的運算子計數器部分保留的。</p><p translation-origin=\"off\">Names MUST NOT end in <code>With</code>. That is reserved for the operator counter parts of creation functions.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">可以有『結果選擇器』。這是第二個引數，它提供了在值從結果 observable 發出之前『對映』值的能力。</p><p translation-origin=\"off\">MAY have \"result selectors\". This is a secondary argument that provides the ability to \"map\" values before they're emitted from the resulting observable.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">如果建立函式接受『結果選擇器』，則它不能在該結果選擇器之前接受『n-引數』。相反，它應該接受一個陣列或者可能是一個物件。(壞寫法: <code>combineThings(sourceA$, sourceB$, (a, b) => a + b)</code> 好寫法: <code>combineThings([sourceA$, sourceB$], (a, b) => a + b)</code>。在這種情況下，將結果選擇器作為第二個引數而不是作為命名引數提供會更好，因為其用法相當明顯。</p><p translation-origin=\"off\">IF the creation function accepts a \"result selector\", it must not accept \"n-arguments\" ahead of that result selector. Instead, it should accept an array or possibly an object. (bad: <code>combineThings(sourceA$, sourceB$, (a, b) => a + b)</code>, good: <code>combineThings([sourceA$, sourceB$], (a, b) => a + b)</code>. In this case, it may be okay to provide the result selector as a second argument, rather than as a named parameter, as the use should be fairly obvious.</p>\n\n</li>\n</ul>\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/index/class/Observable\n - api/index/function/concat\n - api/index/function/concatWith\n - api/index/function/from\n - api/index/function/map\n - api/index/function/of\n - api/index/function/skip\n - api/index/function/take\n - api/index/function/takeUntil\n - guide/core-semantics#creation-functions\n - guide/core-semantics#general-design-guidelines\n - guide/core-semantics#operators\n - guide/core-semantics#purpose\n - guide/core-semantics#rxjs-core-semantics\n - https://en.wikipedia.org/wiki/Referential_transparency\n - https://github.com/ReactiveX/rxjs/issues\n - https://rxjs.dev/api/index/interface/OperatorFunction\n-->"
}