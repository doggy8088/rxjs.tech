{
  "id": "guide/scheduler",
  "title": "",
  "contents": "\n<div class=\"content\">\n<h1 id=\"scheduler\" translation-result=\"on\">排程器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/scheduler#scheduler\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"scheduler\">Scheduler<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/scheduler#scheduler\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\"><strong>什麼是排程器？</strong>排程器控制某個訂閱何時開始以及何時傳遞通知。它由三個部件組成。</p><p translation-origin=\"off\"><strong>What is a Scheduler?</strong> A scheduler controls when a subscription starts and when notifications are delivered. It consists of three components.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><strong>排程器是一種資料結構。</strong>它知道如何根據優先級或其它標準來儲存和對任務進行排隊。</p><p translation-origin=\"off\"><strong>A Scheduler is a data structure.</strong> It knows how to store and queue tasks based on priority or other criteria.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>排程器是一個執行上下文。</strong>它表示任務在何時何地執行（例如立即執行，或在另一個回呼機制中，如 setTimeout 或 process.nextTick，或動畫幀）。</p><p translation-origin=\"off\"><strong>A Scheduler is an execution context.</strong> It denotes where and when the task is executed (e.g. immediately, or in another callback mechanism such as setTimeout or process.nextTick, or the animation frame).</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>排程器有一個（虛擬）時鐘。</strong>它透過排程器上的 getter 方法 <code>now()</code> 提供了『時間』的概念。在特定排程器上排程的任務將僅遵守該時鐘指示的時間。</p><p translation-origin=\"off\"><strong>A Scheduler has a (virtual) clock.</strong> It provides a notion of \"time\" by a getter method <code>now()</code> on the scheduler. Tasks being scheduled on a particular scheduler will adhere only to the time denoted by that clock.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\"><span class=\"informal\">排程器允許你定義 Observable 將在什麼執行上下文中向其 Observer 傳遞通知。</span></p><p translation-origin=\"off\"><span class=\"informal\">A Scheduler lets you define in what execution context will an Observable deliver notifications to its Observer.</span></p>\n\n<p translation-result=\"on\">在下面的範例中，我們採用通常的簡單 Observable 同步傳送值 <code>1</code>、<code>2</code>、<code>3</code>，並使用運算子 <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> 指定用於傳遞這些值的 <code>async</code> 排程器。</p><p translation-origin=\"off\">In the example below, we take the usual simple Observable that emits values <code>1</code>, <code>2</code>, <code>3</code> synchronously, and use the operator <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> to specify the <code>async</code> scheduler to use for delivering those values.</p>\n\n<!-- prettier-ignore -->\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>, <a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a>, <a href=\"api/index/const/asyncScheduler\" class=\"code-anchor\">asyncScheduler</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>((observer) => {\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n  observer.complete();\n}).pipe(\n  <a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a>(<a href=\"api/index/const/asyncScheduler\" class=\"code-anchor\">asyncScheduler</a>)\n);\n\nconsole.log('just before subscribe');\nobservable.subscribe({\n  next(x) {\n    console.log('got value ' + x);\n  },\n  error(err) {\n    console.error('something wrong occurred: ' + err);\n  },\n  complete() {\n    console.log('done');\n  },\n});\nconsole.log('just after subscribe');\n</code-example>\n<p translation-result=\"on\">與輸出一起執行：</p><p translation-origin=\"off\">Which executes with the output:</p>\n\n<code-example language=\"none\">\njust before subscribe\njust after subscribe\ngot value 1\ngot value 2\ngot value 3\ndone\n</code-example>\n<p translation-result=\"on\">請注意本通知的 <code>got value...</code> 是在 <code>just after subscribe</code> 收到的，這與我們目前看到的預設行為不同。這是因為 <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a>(<a href=\"api/index/const/asyncScheduler\" class=\"code-anchor\">asyncScheduler</a>)</code> 在 <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code> 和最終的 Observer 之間引入了一個代理 Observer。讓我們重新命名一些識別符號，以使範例程式碼中的區別顯而易見：</p><p translation-origin=\"off\">Notice how the notifications <code>got value...</code> were delivered after <code>just after subscribe</code>, which is different to the default behavior we have seen so far. This is because <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a>(<a href=\"api/index/const/asyncScheduler\" class=\"code-anchor\">asyncScheduler</a>)</code> introduces a proxy Observer between <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code> and the final Observer. Let's rename some identifiers to make that distinction obvious in the example code:</p>\n\n<!-- prettier-ignore -->\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>, <a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a>, <a href=\"api/index/const/asyncScheduler\" class=\"code-anchor\">asyncScheduler</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>((proxyObserver) => {\n  proxyObserver.next(1);\n  proxyObserver.next(2);\n  proxyObserver.next(3);\n  proxyObserver.complete();\n}).pipe(\n  <a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a>(<a href=\"api/index/const/asyncScheduler\" class=\"code-anchor\">asyncScheduler</a>)\n);\n\nconst finalObserver = {\n  next(x) {\n    console.log('got value ' + x);\n  },\n  error(err) {\n    console.error('something wrong occurred: ' + err);\n  },\n  complete() {\n    console.log('done');\n  },\n};\n\nconsole.log('just before subscribe');\nobservable.subscribe(finalObserver);\nconsole.log('just after subscribe');\n</code-example>\n<p translation-result=\"on\"><code>proxyObserver</code> 是在 <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a>(<a href=\"api/index/const/asyncScheduler\" class=\"code-anchor\">asyncScheduler</a>)</code> 中建立的，它的 <code>next(val)</code> 函式大致如下：</p><p translation-origin=\"off\">The <code>proxyObserver</code> is created in <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a>(<a href=\"api/index/const/asyncScheduler\" class=\"code-anchor\">asyncScheduler</a>)</code>, and its <code>next(val)</code> function is approximately the following:</p>\n\n<!-- prettier-ignore -->\n<code-example language=\"ts\">\nconst proxyObserver = {\n  next(val) {\n    asyncScheduler.schedule(\n      (x) => finalObserver.next(x),\n      0 /* <a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a> */,\n      val /* will be the x for the function above */\n    );\n  },\n\n  // ...\n};\n</code-example>\n<p translation-result=\"on\"><code>async</code> 排程器使用 <code>setTimeout</code> 或 <code>setInterval</code> 執行，即使給定的 <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code> 為零。像往常一樣，在 JavaScript 中，已知 <code>setTimeout(fn, 0)</code> 在下一次事件迴圈迭代中最早執行函式 <code>fn</code>。這就解釋了為什麼在 <code>just after subscribe</code> 發生後會將 <code>got value 1</code> 傳遞給 <code>finalObserver</code>。</p><p translation-origin=\"off\">The <code>async</code> Scheduler operates with a <code>setTimeout</code> or <code>setInterval</code>, even if the given <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code> was zero. As usual, in JavaScript, <code>setTimeout(fn, 0)</code> is known to run the function <code>fn</code> earliest on the next event loop iteration. This explains why <code>got value 1</code> is delivered to the <code>finalObserver</code> after <code>just after subscribe</code> happened.</p>\n\n<p translation-result=\"on\">Scheduler 的 <code>schedule()</code> 方法會接受一個 <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code> 引數，它指的是相對於 Scheduler 內部時鐘的時間量。排程器的時鐘不需要與實際的鐘錶時間有任何關係。這就是像 <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code> 這樣的時間運算子不是在實際時間上執行的，而是在排程器時鐘指定的時間上執行的。這在測試中特別有用，其中可以使用<em>虛擬時間排程器</em>來偽造掛鐘時間，而實際上是同步執行計劃任務。</p><p translation-origin=\"off\">The <code>schedule()</code> method of a Scheduler takes a <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code> argument, which refers to a quantity of time relative to the Scheduler's own internal clock. A Scheduler's clock need not have any relation to the actual wall-clock time. This is how temporal operators like <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code> operate not on actual time, but on time dictated by the Scheduler's clock. This is specially useful in testing, where a <em>virtual time Scheduler</em> may be used to fake wall-clock time while in reality executing scheduled tasks synchronously.</p>\n\n<h2 id=\"scheduler-types\" translation-result=\"on\">排程器型別<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/scheduler#scheduler-types\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"scheduler-types\">Scheduler Types<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/scheduler#scheduler-types\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code>async</code> 排程器是 RxJS 提供的內建排程器之一。這些中的每一個都可以透過使用 <code><a href=\"api/index/class/Scheduler\" class=\"code-anchor\">Scheduler</a></code> 物件的靜態屬性來建立和回傳。</p><p translation-origin=\"off\">The <code>async</code> Scheduler is one of the built-in schedulers provided by RxJS. Each of these can be created and returned by using static properties of the <code><a href=\"api/index/class/Scheduler\" class=\"code-anchor\">Scheduler</a></code> object.</p>\n\n<table>\n<thead>\n<tr>\n<th><p translation-result=\"on\">排程器</p><p translation-origin=\"off\">Scheduler</p></th>\n<th><p translation-result=\"on\">用途</p><p translation-origin=\"off\">Purpose</p></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td><code>null</code></td>\n<td><p translation-result=\"on\">不傳遞任何排程器，通知將以同步和遞迴方式傳遞。要把它用於恆定時間操作或尾遞迴操作。</p><p translation-origin=\"off\">By not passing any scheduler, notifications are delivered synchronously and recursively. Use this for constant-time operations or tail recursive operations.</p></td>\n</tr>\n\n<tr>\n<td><code><a href=\"api/index/const/queueScheduler\" class=\"code-anchor\">queueScheduler</a></code></td>\n<td><p translation-result=\"on\">在當前事件框架（蹦床排程器）中的佇列上排程。將其用於迭代操作。</p><p translation-origin=\"off\">Schedules on a queue in the current event frame (trampoline scheduler). Use this for iteration operations.</p></td>\n</tr>\n\n<tr>\n<td><code><a href=\"api/index/const/asapScheduler\" class=\"code-anchor\">asapScheduler</a></code></td>\n<td><p translation-result=\"on\">在微任務佇列上排程，這與用於 Promise 的佇列相同。基本上在當前工作之後，但在下一個工作之前。這些將用於非同步轉換。</p><p translation-origin=\"off\">Schedules on the micro task queue, which is the same queue used for promises. Basically after the current job, but before the next job. Use this for asynchronous conversions.</p></td>\n</tr>\n\n<tr>\n<td><code><a href=\"api/index/const/asyncScheduler\" class=\"code-anchor\">asyncScheduler</a></code></td>\n<td><p translation-result=\"on\">使用 <code>setInterval</code> 的排程器。將此用於基於時間的操作。</p><p translation-origin=\"off\">Schedules work with <code>setInterval</code>. Use this for time-based operations.</p></td>\n</tr>\n\n<tr>\n<td><code><a href=\"api/index/const/animationFrameScheduler\" class=\"code-anchor\">animationFrameScheduler</a></code></td>\n<td><p translation-result=\"on\">排程將在下一次瀏覽器內容重繪之前發生的任務。可用於建立流暢的瀏覽器動畫。</p><p translation-origin=\"off\">Schedules task that will happen just before next browser content repaint. Can be used to create smooth browser animations.</p></td>\n</tr>\n\n</tbody>\n</table>\n<h2 id=\"using-schedulers\" translation-result=\"on\">使用排程器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/scheduler#using-schedulers\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"using-schedulers\">Using Schedulers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/scheduler#using-schedulers\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可能已經在你的 RxJS 程式碼中使用了排程器，而沒有明確說明要使用的排程器的型別。這是因為所有處理併發的 Observable 運算子都有可選的排程器。如果你不提供排程器，RxJS 會根據最少併發的原則選擇一個預設的排程器。這意味著會選擇引入滿足運算子需求的最少併發量的排程器。例如，對於回傳具有有限且少量訊息的 observable 的運算子，RxJS 不使用排程器，即 <code>null</code> 或 <code>undefined</code>。對於回傳可能大量或無限數量的訊息的運算子，會使用 <code><a href=\"api/index/const/queue\" class=\"code-anchor\">queue</a></code> 排程器。對於使用計時器的運算子，會使用 <code>async</code> 排程器。</p><p translation-origin=\"off\">You may have already used schedulers in your RxJS code without explicitly stating the type of schedulers to be used. This is because all Observable operators that deal with concurrency have optional schedulers. If you do not provide the scheduler, RxJS will pick a default scheduler by using the principle of least concurrency. This means that the scheduler which introduces the least amount of concurrency that satisfies the needs of the operator is chosen. For example, for operators returning an observable\nwith a finite and small number of messages, RxJS uses no Scheduler, i.e. <code>null</code> or <code>undefined</code>. For operators returning a potentially large or infinite number of messages, <code><a href=\"api/index/const/queue\" class=\"code-anchor\">queue</a></code> Scheduler is used. For operators which use timers, <code>async</code> is used.</p>\n\n<p translation-result=\"on\">因為 RxJS 使用會最少併發排程器，如果你想為了效能目的而引入併發，你可以選擇一個不同的排程器。要指定特定的排程器，你可以使用那些能接收排程器的運算子方法，例如 <code><a href=\"api/index/function/from\" class=\"code-anchor\">from</a>([10, 20, 30], <a href=\"api/index/const/asyncScheduler\" class=\"code-anchor\">asyncScheduler</a>)</code>。</p><p translation-origin=\"off\">Because RxJS uses the least concurrency scheduler, you can pick a different scheduler if you want to introduce concurrency for performance purpose. To specify a particular scheduler, you can use those operator methods that take a scheduler, e.g., <code><a href=\"api/index/function/from\" class=\"code-anchor\">from</a>([10, 20, 30], <a href=\"api/index/const/asyncScheduler\" class=\"code-anchor\">asyncScheduler</a>)</code>.</p>\n\n<p translation-result=\"on\"><strong>靜態建立運算子通常以某個 Scheduler 作為引數。</strong>例如，<code><a href=\"api/index/function/from\" class=\"code-anchor\">from</a>(array, scheduler)</code> 允許你指定在傳遞從 <code>array</code> 轉換出來的每個通知時要使用的排程器。它通常是運算子的最後一個引數。以下靜態建立運算子會接收 Scheduler 引數：</p><p translation-origin=\"off\"><strong>Static creation operators usually take a Scheduler as argument.</strong> For instance, <code><a href=\"api/index/function/from\" class=\"code-anchor\">from</a>(array, scheduler)</code> lets you specify the Scheduler to use when delivering each notification converted from the <code>array</code>. It is usually the last argument to the operator. The following static creation operators take a Scheduler argument:</p>\n\n<ul>\n<li><code><a href=\"api/index/function/bindCallback\" class=\"code-anchor\">bindCallback</a></code></li>\n<li><code><a href=\"api/index/function/bindNodeCallback\" class=\"code-anchor\">bindNodeCallback</a></code></li>\n<li><code><a href=\"api/index/function/combineLatest\" class=\"code-anchor\">combineLatest</a></code></li>\n<li><code><a href=\"api/index/function/concat\" class=\"code-anchor\">concat</a></code></li>\n<li><code><a href=\"api/index/function/empty\" class=\"code-anchor\">empty</a></code></li>\n<li><code><a href=\"api/index/function/from\" class=\"code-anchor\">from</a></code></li>\n<li><code>fromPromise</code></li>\n<li><code><a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a></code></li>\n<li><code><a href=\"api/index/function/merge\" class=\"code-anchor\">merge</a></code></li>\n<li><code><a href=\"api/index/function/of\" class=\"code-anchor\">of</a></code></li>\n<li><code><a href=\"api/index/function/range\" class=\"code-anchor\">range</a></code></li>\n<li><code>throw</code></li>\n<li><code><a href=\"api/index/function/timer\" class=\"code-anchor\">timer</a></code></li>\n</ul>\n<p translation-result=\"on\"><strong>使用 <code><a href=\"api/index/function/subscribeOn\" class=\"code-anchor\">subscribeOn</a></code> 來安排 <code>subscribe()</code> 在什麼上下文中發生呼叫。</strong>預設情況下，對 Observable 的 <code>subscribe()</code> 呼叫將同步並立即發生。但是，你可以使用實例運算子 <code><a href=\"api/index/function/subscribeOn\" class=\"code-anchor\">subscribeOn</a>(scheduler)</code> 來推遲或安排在給定排程器上發生的實際訂閱，其中 <code>scheduler</code> 是你要提供的引數。</p><p translation-origin=\"off\"><strong>Use <code><a href=\"api/index/function/subscribeOn\" class=\"code-anchor\">subscribeOn</a></code> to schedule in what context will the <code>subscribe()</code> call happen.</strong> By default, a <code>subscribe()</code> call on an Observable will happen synchronously and immediately. However, you may delay or schedule the actual subscription to happen on a given Scheduler, using the instance operator <code><a href=\"api/index/function/subscribeOn\" class=\"code-anchor\">subscribeOn</a>(scheduler)</code>, where <code>scheduler</code> is an argument you provide.</p>\n\n<p translation-result=\"on\"><strong>使用 <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> 來安排在什麼上下文中傳送通知。</strong>正如我們在上面的例子中看到的，實例運算子 <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a>(scheduler)</code> 在源 Observable 和目標 Observer 之間引入了一個中介 Observer，此中介會使用給定的 <code>scheduler</code> 排程對目標 Observer 的呼叫。</p><p translation-origin=\"off\"><strong>Use <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> to schedule in what context will notifications be delivered.</strong> As we saw in the examples above, instance operator <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a>(scheduler)</code> introduces a mediator Observer between the source Observable and the destination Observer, where the mediator schedules calls to the destination Observer using your given <code>scheduler</code>.</p>\n\n<p translation-result=\"on\"><strong>實例運算子可以將排程器作為引數。</strong></p><p translation-origin=\"off\"><strong>Instance operators may take a Scheduler as argument.</strong></p>\n\n<p translation-result=\"on\">與時間相關的運算子，如 <code><a href=\"api/index/function/bufferTime\" class=\"code-anchor\">bufferTime</a></code>、<code><a href=\"api/index/function/debounceTime\" class=\"code-anchor\">debounceTime</a></code>、<code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code>、<code><a href=\"api/index/function/auditTime\" class=\"code-anchor\">auditTime</a></code>、<code><a href=\"api/index/function/sampleTime\" class=\"code-anchor\">sampleTime</a></code>、<code><a href=\"api/index/function/throttleTime\" class=\"code-anchor\">throttleTime</a></code>、<code><a href=\"api/index/function/timeInterval\" class=\"code-anchor\">timeInterval</a></code>、<code><a href=\"api/index/function/timeout\" class=\"code-anchor\">timeout</a></code>、<code><a href=\"api/index/function/timeoutWith\" class=\"code-anchor\">timeoutWith</a></code>、<code><a href=\"api/index/function/windowTime\" class=\"code-anchor\">windowTime</a></code> 都將 Scheduler 作為最後一個引數，否則預設在 <code><a href=\"api/index/const/asyncScheduler\" class=\"code-anchor\">asyncScheduler</a></code> 上執行。</p><p translation-origin=\"off\">Time-related operators like <code><a href=\"api/index/function/bufferTime\" class=\"code-anchor\">bufferTime</a></code>, <code><a href=\"api/index/function/debounceTime\" class=\"code-anchor\">debounceTime</a></code>, <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code>, <code><a href=\"api/index/function/auditTime\" class=\"code-anchor\">auditTime</a></code>, <code><a href=\"api/index/function/sampleTime\" class=\"code-anchor\">sampleTime</a></code>, <code><a href=\"api/index/function/throttleTime\" class=\"code-anchor\">throttleTime</a></code>, <code><a href=\"api/index/function/timeInterval\" class=\"code-anchor\">timeInterval</a></code>, <code><a href=\"api/index/function/timeout\" class=\"code-anchor\">timeout</a></code>, <code><a href=\"api/index/function/timeoutWith\" class=\"code-anchor\">timeoutWith</a></code>, <code><a href=\"api/index/function/windowTime\" class=\"code-anchor\">windowTime</a></code> all take a Scheduler as the last argument, and otherwise operate by default on the <code><a href=\"api/index/const/asyncScheduler\" class=\"code-anchor\">asyncScheduler</a></code>.</p>\n\n<p translation-result=\"on\">其它以 Scheduler 作為引數的實例運算子有：<code>cache</code>、<code><a href=\"api/index/function/combineLatest\" class=\"code-anchor\">combineLatest</a></code>、<code><a href=\"api/index/function/concat\" class=\"code-anchor\">concat</a></code>、<code><a href=\"api/index/function/expand\" class=\"code-anchor\">expand</a></code>、<code><a href=\"api/index/function/merge\" class=\"code-anchor\">merge</a></code>、<code><a href=\"api/index/function/publishReplay\" class=\"code-anchor\">publishReplay</a></code>、<code><a href=\"api/index/function/startWith\" class=\"code-anchor\">startWith</a></code>。</p><p translation-origin=\"off\">Other instance operators that take a Scheduler as argument: <code>cache</code>, <code><a href=\"api/index/function/combineLatest\" class=\"code-anchor\">combineLatest</a></code>, <code><a href=\"api/index/function/concat\" class=\"code-anchor\">concat</a></code>, <code><a href=\"api/index/function/expand\" class=\"code-anchor\">expand</a></code>, <code><a href=\"api/index/function/merge\" class=\"code-anchor\">merge</a></code>, <code><a href=\"api/index/function/publishReplay\" class=\"code-anchor\">publishReplay</a></code>, <code><a href=\"api/index/function/startWith\" class=\"code-anchor\">startWith</a></code>.</p>\n\n<p translation-result=\"on\">請注意，<code>cache</code> 和 <code><a href=\"api/index/function/publishReplay\" class=\"code-anchor\">publishReplay</a></code> 都接受 Scheduler，因為它們使用了 ReplaySubject。ReplaySubjects 的建構式函式將可選的 Scheduler 作為最後一個引數，因為 ReplaySubject 可能會處理時間，這僅在 Scheduler 的上下文中才有意義。預設情況下，ReplaySubject 會使用 <code><a href=\"api/index/const/queue\" class=\"code-anchor\">queue</a></code> 排程器提供時鐘。</p><p translation-origin=\"off\">Notice that both <code>cache</code> and <code><a href=\"api/index/function/publishReplay\" class=\"code-anchor\">publishReplay</a></code> accept a Scheduler because they utilize a ReplaySubject. The constructor of a ReplaySubjects takes an optional Scheduler as the last argument because ReplaySubject may deal with time, which only makes sense in the context of a Scheduler. By default, a ReplaySubject uses the <code><a href=\"api/index/const/queue\" class=\"code-anchor\">queue</a></code> Scheduler to provide a clock.</p>\n\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/index/class/Observable\n - api/index/class/Scheduler\n - api/index/const/animationFrameScheduler\n - api/index/const/asapScheduler\n - api/index/const/asyncScheduler\n - api/index/const/observable\n - api/index/const/queue\n - api/index/const/queueScheduler\n - api/index/function/auditTime\n - api/index/function/bindCallback\n - api/index/function/bindNodeCallback\n - api/index/function/bufferTime\n - api/index/function/combineLatest\n - api/index/function/concat\n - api/index/function/debounceTime\n - api/index/function/delay\n - api/index/function/empty\n - api/index/function/expand\n - api/index/function/from\n - api/index/function/interval\n - api/index/function/merge\n - api/index/function/observeOn\n - api/index/function/of\n - api/index/function/publishReplay\n - api/index/function/range\n - api/index/function/sampleTime\n - api/index/function/startWith\n - api/index/function/subscribeOn\n - api/index/function/throttleTime\n - api/index/function/timeInterval\n - api/index/function/timeout\n - api/index/function/timeoutWith\n - api/index/function/timer\n - api/index/function/windowTime\n - guide/scheduler#scheduler\n - guide/scheduler#scheduler-types\n - guide/scheduler#using-schedulers\n-->"
}