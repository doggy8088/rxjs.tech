{
  "id": "guide/higher-order-observables",
  "title": "",
  "contents": "\n<div class=\"content\">\n<h1 id=\"higher-order-observables\" translation-result=\"on\">高階 Observable<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/higher-order-observables#higher-order-observables\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"higher-order-observables\">Higher-order Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/higher-order-observables#higher-order-observables\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">Observable 通常會發出普通值，如字串和數字，但令人驚訝的是，經常有需要處理 Observable<em>的</em> Observable，即所謂的高階 Observable。例如，假設你有一個會發出字串的 Observable，這些字串是你要獲取的檔案的 URL。程式碼可能如下所示：</p><p translation-origin=\"off\">Observables most commonly emit ordinary values like strings and numbers, but surprisingly often, it is necessary to handle Observables <em>of</em> Observables, so-called higher-order Observables. For example, imagine you have an Observable emitting strings that are the URLs of files you want to fetch. The code might look like this:</p>\n\n<code-example language=\"ts\">\nconst fileObservable = urlObservable.pipe(<a href=\"api/index/function/map\" class=\"code-anchor\">map</a>((url) => http.get(url)));\n</code-example>\n<p translation-result=\"on\"><code>http.get()</code> 會為每個 URL 回傳一個 Observable。現在你有了一個 Observable<em>的</em> Observable，也就是高階 Observable。</p><p translation-origin=\"off\"><code>http.get()</code> returns an Observable for each URL. Now you have an Observable <em>of</em> Observables, a higher-order Observable.</p>\n\n<p translation-result=\"on\">但是你如何使用更高階的 Observable 呢？通常，透過<em>展平</em>來將高階 Observable 轉換為普通的 Observable。例如：</p><p translation-origin=\"off\">But how do you work with a higher-order Observable? Typically, by <em>flattening</em>: by converting a higher-order Observable into an ordinary Observable. For example:</p>\n\n<code-example language=\"ts\">\nconst fileObservable = urlObservable.pipe(<a href=\"api/index/function/concatMap\" class=\"code-anchor\">concatMap</a>((url) => http.get(url)));\n</code-example>\n<p translation-result=\"on\"><code><a href=\"api/index/function/concatMap\" class=\"code-anchor\">concatMap</a></code> 函式中回傳的 Observable 通常稱為所謂的『內部』 Observable，而在這個上下文中，<code>urlObservable</code> 就是所謂的『外部』 Observable。</p><p translation-origin=\"off\">The Observable returned in the <code><a href=\"api/index/function/concatMap\" class=\"code-anchor\">concatMap</a></code> function is usually referred to as a so-called \"inner\" Observable, while in this context the <code>urlObservable</code> is the so-called \"outer\" Observable.</p>\n\n<p translation-result=\"on\"><a href=\"/api/operators/concatMap\"><code>concatMap()</code></a> 運算子會訂閱每個『內部』 Observable，緩衝『外部』 Observable 的所有進一步傳送，並複製所有已傳送的值，直到內部 Observable 完成，並繼續處理『外部 Observable』的值。所有值都以這種方式連線。其它有用的展平運算子有</p><p translation-origin=\"off\">The <a href=\"/api/operators/concatMap\"><code>concatMap()</code></a> operator subscribes to each \"inner\" Observable, buffers all further emissions of the \"outer\" Observable, and copies all the emitted values until the inner Observable completes, and continues processing the values of the \"outer Observable\". All of the values are in that way concatenated. Other useful flattening operators are</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><a href=\"/api/operators/mergeMap\"><code>mergeMap()</code></a> — 在每個內部 Observable 抵達時訂閱它，然後在每個值抵達時發出這個值</p><p translation-origin=\"off\"><a href=\"/api/operators/mergeMap\"><code>mergeMap()</code></a> — subscribes to each inner Observable as it arrives, then emits each value as it arrives</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"/api/operators/switchMap\"><code>switchMap()</code></a> — 在第一個內部 Observable 抵達時訂閱它，並在它抵達時發出每個值，但是當下一個內部 Observable 抵達時，退訂前一個，並訂閱新的。</p><p translation-origin=\"off\"><a href=\"/api/operators/switchMap\"><code>switchMap()</code></a> — subscribes to the first inner Observable when it arrives, and emits each value as it arrives, but when the next inner Observable arrives, unsubscribes to the previous one, and subscribes to the new one.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"/api/operators/exhaustMap\"><code>exhaustMap()</code></a> - 當第一個內部 Observable 抵達時訂閱它，並在它抵達時發出每個值，丟棄所有新抵達的內部 Observable 直到第一個完成，然後等待下一個內部 Observable。</p><p translation-origin=\"off\"><a href=\"/api/operators/exhaustMap\"><code>exhaustMap()</code></a> — subscribes to the first inner Observable when it arrives, and emits each value as it arrives, discarding all newly arriving inner Observables until that first one completes, then waits for the next inner Observable.</p>\n\n</li>\n</ul>\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /api/operators/concatMap\n - /api/operators/exhaustMap\n - /api/operators/mergeMap\n - /api/operators/switchMap\n - api/index/function/concatMap\n - api/index/function/map\n - guide/higher-order-observables#higher-order-observables\n-->"
}