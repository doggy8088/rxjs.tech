{
  "id": "guide/observable",
  "title": "",
  "contents": "\n<div class=\"content\">\n<h1 id=\"observable\">Observable<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#observable\"><i class=\"material-icons\">link</i></a></h1>\n<h1 id=\"observable（observable）\">Observable（Observable）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#observable（observable）\"><i class=\"material-icons\">link</i></a></h1>\n<p translation-result=\"on\">Observable 是個多值的惰性 Push 集合。他們填補了下表中的缺失點：</p><p translation-origin=\"off\">Observables are lazy Push collections of multiple values. They fill the missing spot in the following table:</p>\n\n<table>\n<thead>\n<tr>\n<th></th>\n<th><p translation-result=\"on\">單值</p><p translation-origin=\"off\">Single</p></th>\n<th><p translation-result=\"on\">多值</p><p translation-origin=\"off\">Multiple</p></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td><p translation-result=\"on\"><strong>拉</strong></p><p translation-origin=\"off\"><strong>Pull</strong></p></td>\n<td><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Function\"><code>Function</code></a></td>\n<td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\"><code>Iterator</code></a></td>\n</tr>\n\n<tr>\n<td><p translation-result=\"on\"><strong>推</strong></p><p translation-origin=\"off\"><strong>Push</strong></p></td>\n<td><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a></td>\n<td><a href=\"/api/index/class/Observable\"><code>Observable</code></a></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\"><strong>例子。</strong>下面是一個 Observable，它在訂閱時立即（同步）推送值 <code>1</code>、<code>2</code>、<code>3</code>，並且在 subscribe 呼叫過一秒之後推送值 <code>4</code>，然後完成：</p><p translation-origin=\"off\"><strong>Example.</strong> The following is an Observable that pushes the values <code>1</code>, <code>2</code>, <code>3</code> immediately (synchronously) when subscribed, and the value <code>4</code> after one second has passed since the subscribe call, then completes:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>((subscriber) => {\n  subscriber.next(1);\n  subscriber.next(2);\n  subscriber.next(3);\n  setTimeout(() => {\n    subscriber.next(4);\n    subscriber.complete();\n  }, 1000);\n});\n</code-example>\n<p translation-result=\"on\">要呼叫 Observable 並檢視這些值，我們需要<em>訂閱</em>它：</p><p translation-origin=\"off\">To invoke the Observable and see these values, we need to <em>subscribe</em> to it:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>((subscriber) => {\n  subscriber.next(1);\n  subscriber.next(2);\n  subscriber.next(3);\n  setTimeout(() => {\n    subscriber.next(4);\n    subscriber.complete();\n  }, 1000);\n});\n\nconsole.log('just before subscribe');\nobservable.subscribe({\n  next(x) {\n    console.log('got value ' + x);\n  },\n  error(err) {\n    console.error('something wrong occurred: ' + err);\n  },\n  complete() {\n    console.log('done');\n  },\n});\nconsole.log('just after subscribe');\n</code-example>\n<p translation-result=\"on\">在控制台上執行結果如下：</p><p translation-origin=\"off\">Which executes as such on the console:</p>\n\n<code-example language=\"none\">\njust before subscribe\ngot value 1\ngot value 2\ngot value 3\njust after subscribe\ngot value 4\ndone\n</code-example>\n<h2 id=\"pull-versus-push\" translation-result=\"on\">拉取與推送<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#pull-versus-push\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"pull-versus-push\">Pull versus Push<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#pull-versus-push\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><em>拉取（Pull）</em>和<em>推送（Push）</em>是兩種不同的協定，用於描述資料<em>生產者（Producer）</em>如何與資料<em>消費者（Consumer）</em>通訊。</p><p translation-origin=\"off\"><em>Pull</em> and <em>Push</em> are two different protocols that describe how a data <em>Producer</em> can communicate with a data <em>Consumer</em>.</p>\n\n<p translation-result=\"on\"><strong>什麼是拉取？</strong>在拉取體系中，由消費者確定何時從資料生產者接收資料。而生產者本身不知道資料何時交付給消費者。</p><p translation-origin=\"off\"><strong>What is Pull?</strong> In Pull systems, the Consumer determines when it receives data from the data Producer. The Producer itself is unaware of when the data will be delivered to the Consumer.</p>\n\n<p translation-result=\"on\">每個 JavaScript 函式都是一個拉取系統。該函式是資料的生產者，呼叫該函式的程式碼透過從其呼叫中『拉取』出<em>單個</em>回傳值來使用它。</p><p translation-origin=\"off\">Every JavaScript Function is a Pull system. The function is a Producer of data, and the code that calls the function is consuming it by \"pulling\" out a <em>single</em> return value from its call.</p>\n\n<p translation-result=\"on\">ES2015 引入了<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\">產生器函式和迭代器</a>（<code>function*</code>），它是另一種型別的拉取體系。呼叫 <code>iterator.next()</code> 的程式碼是消費者，它從迭代器（生產者）『拉取』出<em>多個</em>值。</p><p translation-origin=\"off\">ES2015 introduced <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\">generator functions and iterators</a> (<code>function*</code>), another type of Pull system. Code that calls <code>iterator.next()</code> is the Consumer, \"pulling\" out <em>multiple</em> values from the iterator (the Producer).</p>\n\n<table>\n<thead>\n<tr>\n<th></th>\n<th><p translation-result=\"on\">生產者</p><p translation-origin=\"off\">Producer</p></th>\n<th><p translation-result=\"on\">消費者</p><p translation-origin=\"off\">Consumer</p></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td><p translation-result=\"on\"><strong>拉取</strong></p><p translation-origin=\"off\"><strong>Pull</strong></p></td>\n<td><p translation-result=\"on\"><strong>被動：</strong>在請求時產生資料。</p><p translation-origin=\"off\"><strong>Passive:</strong> produces data when requested.</p></td>\n<td><p translation-result=\"on\"><strong>主動：</strong>決定何時請求資料。</p><p translation-origin=\"off\"><strong>Active:</strong> decides when data is requested.</p></td>\n</tr>\n\n<tr>\n<td><p translation-result=\"on\"><strong>推送</strong></p><p translation-origin=\"off\"><strong>Push</strong></p></td>\n<td><p translation-result=\"on\"><strong>主動：</strong>按照自己的節奏生成資料。</p><p translation-origin=\"off\"><strong>Active:</strong> produces data at its own pace.</p></td>\n<td><p translation-result=\"on\"><strong>被動：</strong>對接收到的資料做出回應。</p><p translation-origin=\"off\"><strong>Passive:</strong> reacts to received data.</p></td>\n</tr>\n\n</tbody>\n</table>\n<p translation-result=\"on\"><strong>什麼是推送？</strong>在推送體系中，由生產者決定何時向消費者傳送資料。而消費者不知道何時會收到該資料。</p><p translation-origin=\"off\"><strong>What is Push?</strong> In Push systems, the Producer determines when to send data to the Consumer. The Consumer is unaware of when it will receive that data.</p>\n\n<p translation-result=\"on\">Promise 是當今 JavaScript 中最常見的推送體系型別。Promise（生產者）向已註冊的回呼（消費者）傳遞解析後的值，但與函式不同的是，Promise 負責準確確定該值何時『推送』到回呼。</p><p translation-origin=\"off\">Promises are the most common type of Push system in JavaScript today. A Promise (the Producer) delivers a resolved value to registered callbacks (the Consumers), but unlike functions, it is the Promise which is in charge of determining precisely when that value is \"pushed\" to the callbacks.</p>\n\n<p translation-result=\"on\">RxJS 引入了 Observables，一個新的 JavaScript 推送體系。Observable 是多個值的生產者，並將它們『推送』給 Observer（消費者）。</p><p translation-origin=\"off\">RxJS introduces Observables, a new Push system for JavaScript. An Observable is a Producer of multiple values, \"pushing\" them to Observers (Consumers).</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><strong>函式</strong>是一種惰性求值的計算，它在呼叫時同步回傳單個值。</p><p translation-origin=\"off\">A <strong>Function</strong> is a lazily evaluated computation that synchronously returns a single value on invocation.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>產生器</strong>是一種惰性求值的計算，它在迭代時同步回傳零到（可能）無限個值。</p><p translation-origin=\"off\">A <strong>generator</strong> is a lazily evaluated computation that synchronously returns zero to (potentially) infinite values on iteration.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>Promise</strong> 是一種可能會（也可能不會）最終回傳單個值的計算。</p><p translation-origin=\"off\">A <strong>Promise</strong> is a computation that may (or may not) eventually return a single value.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>Observable</strong> 是一種惰性求值的計算，從它被呼叫的那一刻起，它可以同步或非同步回傳零個到（可能）無限個值。</p><p translation-origin=\"off\">An <strong>Observable</strong> is a lazily evaluated computation that can synchronously or asynchronously return zero to (potentially) infinite values from the time it's invoked onwards.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\"><span class=\"informal\">有關應該使用什麼將 Observables 轉換為 Promise 的更多訊息，請參閱<a href=\"/deprecations/to-promise\">本指南</a>。</span></p><p translation-origin=\"off\"><span class=\"informal\">For more info about what to use when converting Observables to Promises, please refer to <a href=\"/deprecations/to-promise\">this guide</a>.</span></p>\n\n<h2 id=\"observables-as-generalizations-of-functions\" translation-result=\"on\">Observables 是對函式的泛化<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#observables-as-generalizations-of-functions\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"observables-as-generalizations-of-functions\">Observables as generalizations of functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#observables-as-generalizations-of-functions\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">與流行的說法相反，Observables 不像 EventEmitters 或 Promises 那樣用於多個值。在某些情況下，Observable 的<em>行為可能</em>類似於 EventEmitter，也就是當它們使用 RxJS Subject 進行多播時，但通常它們的行為不像 EventEmitters。</p><p translation-origin=\"off\">Contrary to popular claims, Observables are not like EventEmitters nor are they like Promises for multiple values. Observables <em>may act</em> like EventEmitters in some cases, namely when they are multicasted using RxJS Subjects, but usually they don't act like EventEmitters.</p>\n\n<p translation-result=\"on\"><span class=\"informal\">Observables 類似於無參的函式，但會將它們泛化為允許多個值。</span></p><p translation-origin=\"off\"><span class=\"informal\">Observables are like functions with zero arguments, but generalize those to allow multiple values.</span></p>\n\n<p translation-result=\"on\">考慮下列程式碼：</p><p translation-origin=\"off\">Consider the following:</p>\n\n<code-example language=\"ts\">\nfunction foo() {\n  console.log('Hello');\n  return 42;\n}\n\nconst x = foo.call(); // same as foo()\nconsole.log(x);\nconst y = foo.call(); // same as foo()\nconsole.log(y);\n</code-example>\n<p translation-result=\"on\">我們希望看到如下輸出：</p><p translation-origin=\"off\">We expect to see as output:</p>\n\n<code-example language=\"none\">\n\"Hello\"\n42\n\"Hello\"\n42\n</code-example>\n<p translation-result=\"on\">你可以寫出與剛才一樣的行為，但改用 Observables：</p><p translation-origin=\"off\">You can write the same behavior above, but with Observables:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst foo = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>((subscriber) => {\n  console.log('Hello');\n  subscriber.next(42);\n});\n\nfoo.subscribe((x) => {\n  console.log(x);\n});\nfoo.subscribe((y) => {\n  console.log(y);\n});\n</code-example>\n<p translation-result=\"on\">其輸出是一樣的：</p><p translation-origin=\"off\">And the output is the same:</p>\n\n<code-example language=\"none\">\n\"Hello\"\n42\n\"Hello\"\n42\n</code-example>\n<p translation-result=\"on\">這是因為函式和 Observable 都是惰性計算的。如果你不呼叫該函式，<code>console.log('Hello')</code> 就不會發生。同樣對於 Observables，如果你不『呼叫』它（使用 <code>subscribe</code>），<code>console.log('Hello')</code> 就不會發生。另外，『呼叫』或『訂閱』都是一種孤立的操作：兩個函式呼叫會觸發兩個單獨的副作用，兩個對 Observable 的訂閱會觸發兩個單獨的副作用。與 EventEmitter 共享副作用並且無論訂閱者是否存在都急性執行相反，Observables 不會共享執行並且是惰性的。</p><p translation-origin=\"off\">This happens because both functions and Observables are lazy computations. If you don't call the function, the <code>console.log('Hello')</code> won't happen. Also with Observables, if you don't \"call\" it (with <code>subscribe</code>), the <code>console.log('Hello')</code> won't happen. Plus, \"calling\" or \"subscribing\" is an isolated operation: two function calls trigger two separate side effects, and two Observable subscribes trigger two separate side effects. As opposed to EventEmitters which share the side effects and have eager\nexecution regardless of the existence of subscribers, Observables have no shared execution and are lazy.</p>\n\n<p translation-result=\"on\"><span class=\"informal\">訂閱 Observable 類似於呼叫函式。</span></p><p translation-origin=\"off\"><span class=\"informal\">Subscribing to an Observable is analogous to calling a Function.</span></p>\n\n<p translation-result=\"on\">有些人聲稱 Observables 是非同步的。那不是真的。如果你使用日誌來包裹函式呼叫，如下所示：</p><p translation-origin=\"off\">Some people claim that Observables are asynchronous. That is not true. If you surround a function call with logs, like this:</p>\n\n<code-example language=\"js\">\nconsole.log('before');\nconsole.log(foo.call());\nconsole.log('after');\n</code-example>\n<p translation-result=\"on\">你將看到輸出：</p><p translation-origin=\"off\">You will see the output:</p>\n\n<code-example language=\"none\">\n\"before\"\n\"Hello\"\n42\n\"after\"\n</code-example>\n<p translation-result=\"on\">這與 Observables 的行為相同：</p><p translation-origin=\"off\">And this is the same behavior with Observables:</p>\n\n<code-example language=\"js\">\nconsole.log('before');\nfoo.subscribe((x) => {\n  console.log(x);\n});\nconsole.log('after');\n</code-example>\n<p translation-result=\"on\">其輸出是：</p><p translation-origin=\"off\">And the output is:</p>\n\n<code-example language=\"none\">\n\"before\"\n\"Hello\"\n42\n\"after\"\n</code-example>\n<p translation-result=\"on\">這證明 <code>foo</code> 的訂閱是完全同步的，就像一個函式一樣。</p><p translation-origin=\"off\">Which proves the subscription of <code>foo</code> was entirely synchronous, just like a function.</p>\n\n<p translation-result=\"on\"><span class=\"informal\">Observables 能夠同步或非同步地傳遞值。</span></p><p translation-origin=\"off\"><span class=\"informal\">Observables are able to deliver values either synchronously or asynchronously.</span></p>\n\n<p translation-result=\"on\">Observable 和函式有什麼區別？ <strong>Observables 可以隨著時間的推移『回傳』多個值</strong>，而函式不能。你不能這樣做：</p><p translation-origin=\"off\">What is the difference between an Observable and a function? <strong>Observables can \"return\" multiple values over time</strong>, something which functions cannot. You can't do this:</p>\n\n<code-example language=\"js\">\nfunction foo() {\n  console.log('Hello');\n  return 42;\n  return 100; // dead code. will <a href=\"api/index/function/never\" class=\"code-anchor\">never</a> happen\n}\n</code-example>\n<p translation-result=\"on\">函式只能回傳一個值。然而，Observables 可以這樣做：</p><p translation-origin=\"off\">Functions can only return one value. Observables, however, can do this:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst foo = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>((subscriber) => {\n  console.log('Hello');\n  subscriber.next(42);\n  subscriber.next(100); // \"return\" another value\n  subscriber.next(200); // \"return\" yet another\n});\n\nconsole.log('before');\nfoo.subscribe((x) => {\n  console.log(x);\n});\nconsole.log('after');\n</code-example>\n<p translation-result=\"on\">具有同步輸出：</p><p translation-origin=\"off\">With synchronous output:</p>\n\n<code-example language=\"none\">\n\"before\"\n\"Hello\"\n42\n100\n200\n\"after\"\n</code-example>\n<p translation-result=\"on\">但你也可以非同步『回傳』值：</p><p translation-origin=\"off\">But you can also \"return\" values asynchronously:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst foo = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>((subscriber) => {\n  console.log('Hello');\n  subscriber.next(42);\n  subscriber.next(100);\n  subscriber.next(200);\n  setTimeout(() => {\n    subscriber.next(300); // happens asynchronously\n  }, 1000);\n});\n\nconsole.log('before');\nfoo.subscribe((x) => {\n  console.log(x);\n});\nconsole.log('after');\n</code-example>\n<p translation-result=\"on\">具有輸出：</p><p translation-origin=\"off\">With output:</p>\n\n<code-example language=\"none\">\n\"before\"\n\"Hello\"\n42\n100\n200\n\"after\"\n300\n</code-example>\n<p translation-result=\"on\">結論：</p><p translation-origin=\"off\">Conclusion:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>func.call()</code> 意思是『<em>同步給我一個值</em>』</p><p translation-origin=\"off\"><code>func.call()</code> means \"<em>give me one value synchronously</em>\"</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>observable.subscribe()</code> 的意思是『<em>給我任意數量的值，無論是同步的還是非同步的</em>』</p><p translation-origin=\"off\"><code>observable.subscribe()</code> means \"<em>give me any amount of values, either synchronously or asynchronously</em>\"</p>\n\n</li>\n</ul>\n<h2 id=\"anatomy-of-an-observable\" translation-result=\"on\">Observable 剖析<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#anatomy-of-an-observable\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"anatomy-of-an-observable\">Anatomy of an Observable<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#anatomy-of-an-observable\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Observables 可以使用 <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code> 或<strong>建立型</strong>運算子來建立，由 Observer <strong>訂閱</strong>後，<strong>執行</strong>以便向 Observer 傳遞 <code>next</code> / <code>error</code> / <code>complete</code> 通知，並且它們的執行可能會被<strong>釋放</strong>。這四個方面都編碼在同一個 Observable 實例中，但其中一些方面也會和其它型別有關，例如 Observer 和 Subscription。</p><p translation-origin=\"off\">Observables are <strong>created</strong> using <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code> or a creation operator, are <strong>subscribed</strong> to with an Observer, <strong>execute</strong> to deliver <code>next</code> / <code>error</code> / <code>complete</code> notifications to the Observer, and their execution may be <strong>disposed</strong>. These four aspects are all encoded in an Observable instance, but some of these aspects are related to other types, like Observer and Subscription.</p>\n\n<p translation-result=\"on\">Observable 的核心關注點：</p><p translation-origin=\"off\">Core Observable concerns:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><strong>建立</strong> Observables</p><p translation-origin=\"off\"><strong>Creating</strong> Observables</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>訂閱</strong> Observables</p><p translation-origin=\"off\"><strong>Subscribing</strong> to Observables</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>執行</strong> Observable</p><p translation-origin=\"off\"><strong>Executing</strong> the Observable</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>釋放</strong> Observables</p><p translation-origin=\"off\"><strong>Disposing</strong> Observables</p>\n\n</li>\n</ul>\n<h3 id=\"creating-observables\" translation-result=\"on\">建立 Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#creating-observables\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"creating-observables\">Creating Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#creating-observables\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code> 的建構式函式接受一個引數：<code>subscribe</code> 函式。</p><p translation-origin=\"off\">The <code><a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code> constructor takes one argument: the <code>subscribe</code> function.</p>\n\n<p translation-result=\"on\">下面的範例建立一個 Observable 以每秒向訂閱者傳送字串 <code>'hi'</code>。</p><p translation-origin=\"off\">The following example creates an Observable to emit the string <code>'hi'</code> every second to a subscriber.</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {\n  const id = setInterval(() => {\n    subscriber.next('hi');\n  }, 1000);\n});\n</code-example>\n<p translation-result=\"on\"><span class=\"informal\">可以使用 <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code>。最常見的是， Observable 是使用建立函式建立的，例如 <code><a href=\"api/index/function/of\" class=\"code-anchor\">of</a></code>、<code><a href=\"api/index/function/from\" class=\"code-anchor\">from</a></code>、<code><a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a></code> 等。</span></p><p translation-origin=\"off\"><span class=\"informal\">Observables can be created with <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code>. Most commonly, observables are created using creation functions, like <code><a href=\"api/index/function/of\" class=\"code-anchor\">of</a></code>, <code><a href=\"api/index/function/from\" class=\"code-anchor\">from</a></code>, <code><a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a></code>, etc.</span></p>\n\n<p translation-result=\"on\">在上面的例子中，<code>subscribe</code>（訂閱）函式是描述 Observable 的最重要的部分。讓我們看看訂閱是什麼意思。</p><p translation-origin=\"off\">In the example above, the <code>subscribe</code> function is the most important piece to describe the Observable. Let's look at what subscribing means.</p>\n\n<h3 id=\"subscribing-to-observables\" translation-result=\"on\">訂閱 Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#subscribing-to-observables\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"subscribing-to-observables\">Subscribing to Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#subscribing-to-observables\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">範例中的 Observable <code><a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a></code> 可以被<em>訂閱</em>，如下所示：</p><p translation-origin=\"off\">The Observable <code><a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a></code> in the example can be <em>subscribed</em> to, like this:</p>\n\n<code-example language=\"ts\">\nobservable.subscribe((x) => console.log(x));\n</code-example>\n<p translation-result=\"on\"><code>observable.subscribe</code> 和 <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {...})</code> 中的 <code>subscribe</code> 同名並非巧合。在本庫中，它們是不同的，但從使用角度，你可以認為它們在概念上是相同的。</p><p translation-origin=\"off\">It is not a coincidence that <code>observable.subscribe</code> and <code>subscribe</code> in <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {...})</code> have the same name. In the library, they are different, but for practical purposes you can consider them conceptually equal.</p>\n\n<p translation-result=\"on\">這顯示了 <code>subscribe</code> 呼叫在同一個 Observable 的多個 Observer 之間是不共享的。當以某個 Observer 呼叫 <code>observable.subscribe</code> 時，<code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {...})</code> 中的 <code>subscribe</code> 函式會針對給定的訂閱者執行。對 <code>observable.subscribe</code> 的每次呼叫都會為給定的訂閱者觸發其自己的獨立設定。</p><p translation-origin=\"off\">This shows how <code>subscribe</code> calls are not shared among multiple Observers of the same Observable. When calling <code>observable.subscribe</code> with an Observer, the function <code>subscribe</code> in <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {...})</code> is run for that given subscriber. Each call to <code>observable.subscribe</code> triggers its own independent setup for that given subscriber.</p>\n\n<p translation-result=\"on\"><span class=\"informal\">訂閱 Observable 就像呼叫一個函式，其引數是要傳過去資料的回呼函式。</span></p><p translation-origin=\"off\"><span class=\"informal\">Subscribing to an Observable is like calling a function, providing callbacks where the data will be delivered to.</span></p>\n\n<p translation-result=\"on\">這與 <code>addEventListener</code> / <code>removeEventListener</code> 等事件處理器 API 截然不同。使用 <code>observable.subscribe</code> 時，給定的 Observer 不會在此 Observable 中註冊為監聽器。此 Observable 甚至不會維護附加上來的 Observer 清單。</p><p translation-origin=\"off\">This is drastically different to event handler APIs like <code>addEventListener</code> / <code>removeEventListener</code>. With <code>observable.subscribe</code>, the given Observer is not registered as a listener in the Observable. The Observable does not even maintain a list of attached Observers.</p>\n\n<p translation-result=\"on\"><code>subscribe</code> 呼叫只是一個啟動『 Observable 的執行』並將一些值或事件傳遞給該執行過程的 Observer 的方法。</p><p translation-origin=\"off\">A <code>subscribe</code> call is simply a way to start an \"Observable execution\" and deliver values or events to an Observer of that execution.</p>\n\n<h3 id=\"executing-observables\" translation-result=\"on\">執行 Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#executing-observables\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"executing-observables\">Executing Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#executing-observables\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {...})</code> 中的代碼表示一次 『Observable 執行』，這是一種惰性計算，只發生在每個訂閱的 Observer 上。隨著時間的推移，執行會同步或非同步地產生多個值。</p><p translation-origin=\"off\">The code inside <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {...})</code> represents an \"Observable execution\", a lazy computation that only happens for each Observer that subscribes. The execution produces multiple values over time, either synchronously or asynchronously.</p>\n\n<p translation-result=\"on\">Observable 執行可以傳遞三種型別的值：</p><p translation-origin=\"off\">There are three types of values an Observable Execution can deliver:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">『Next（下一個）』 通知：傳送數值、字串、物件等。</p><p translation-origin=\"off\">\"Next\" notification: sends a value such as a Number, a String, an Object, etc.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">『Error（出錯）』 通知：傳送 JavaScript 錯誤或異常。</p><p translation-origin=\"off\">\"Error\" notification: sends a JavaScript Error or exception.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">『Complete（完成）』通知：不傳送值。</p><p translation-origin=\"off\">\"Complete\" notification: does not send a value.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">『Next』通知是最重要和最常見的型別：它們代表要傳遞給訂閱者的實際資料。在 Observable 執行期間，『Error』和『Complete』通知可能只發生一次，並且只能有其中之一。</p><p translation-origin=\"off\">\"Next\" notifications are the most important and most common type: they represent actual data being delivered to a subscriber. \"Error\" and \"Complete\" notifications may happen only once during the Observable Execution, and there can only be either one of them.</p>\n\n<p translation-result=\"on\">這些約束在所謂的 <em>Observable 語法</em>或<em>契約</em>中表達得最好，寫成正則表示式：</p><p translation-origin=\"off\">These constraints are expressed best in the so-called <em>Observable Grammar</em> or <em>Contract</em>, written as a regular expression:</p>\n\n<code-example language=\"none\">\nnext*(error|complete)?\n</code-example>\n<p translation-result=\"on\"><span class=\"informal\">在 Observable 執行中，可能會傳遞零個到無限個 Next 通知。如果傳送了出錯或完成通知，則之後將無法傳送任何其它通知。</span></p><p translation-origin=\"off\"><span class=\"informal\">In an Observable Execution, zero to infinite Next notifications may be delivered. If either an Error or Complete notification is delivered, then nothing else can be delivered afterwards.</span></p>\n\n<p translation-result=\"on\">下面是一個 Observable 執行的範例，它傳遞三個 Next 通知，然後完成：</p><p translation-origin=\"off\">The following is an example of an Observable execution that delivers three Next notifications, then completes:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {\n  subscriber.next(1);\n  subscriber.next(2);\n  subscriber.next(3);\n  subscriber.complete();\n});\n</code-example>\n<p translation-result=\"on\">Observables 嚴格遵守 Observable 契約，因此以下程式碼不會傳遞 Next 通知 <code>4</code> ：</p><p translation-origin=\"off\">Observables strictly adhere to the Observable Contract, so the following code would not deliver the Next notification <code>4</code>:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {\n  subscriber.next(1);\n  subscriber.next(2);\n  subscriber.next(3);\n  subscriber.complete();\n  subscriber.next(4); // Is not delivered because it would violate the contract\n});\n</code-example>\n<p translation-result=\"on\">使用 <code>try</code> / <code>catch</code> 區塊將任何程式碼包裝在 <code>subscribe</code> 中是一個好主意，如果它捕獲到異常，它將傳遞錯誤通知：</p><p translation-origin=\"off\">It is a good idea to wrap any code in <code>subscribe</code> with <code>try</code>/<code>catch</code> block that will deliver an Error notification if it catches an exception:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {\n  try {\n    subscriber.next(1);\n    subscriber.next(2);\n    subscriber.next(3);\n    subscriber.complete();\n  } catch (err) {\n    subscriber.error(err); // delivers an error if it caught one\n  }\n});\n</code-example>\n<h3 id=\"disposing-observable-executions\" translation-result=\"on\">處理 Observable 執行<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#disposing-observable-executions\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"disposing-observable-executions\">Disposing Observable Executions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/observable#disposing-observable-executions\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">因為 Observable 執行可能是無盡的，並且 Observer 想要在有限時間內中止執行也是很常見的，所以我們需要一個用於取消執行的 API。由於每次執行只針對一個 Observer，一旦 Observer 接收完了值，它必須有辦法停止執行，以避免浪費計算能力或記憶體資源。</p><p translation-origin=\"off\">Because Observable Executions may be infinite, and it's common for an Observer to want to abort execution in finite time, we need an API for canceling an execution. Since each execution is exclusive to one Observer only, once the Observer is done receiving values, it has to have a way to stop the execution, in order to avoid wasting computation power or memory resources.</p>\n\n<p translation-result=\"on\">當 <code>observable.subscribe</code> 被呼叫時，此 Observer 被附加到新創建的 Observable 執行中。此呼叫還會回傳一個物件 <code><a href=\"api/index/class/Subscription\" class=\"code-anchor\">Subscription</a></code> ：</p><p translation-origin=\"off\">When <code>observable.subscribe</code> is called, the Observer gets attached to the newly created Observable execution. This call also returns an object, the <code><a href=\"api/index/class/Subscription\" class=\"code-anchor\">Subscription</a></code>:</p>\n\n<code-example language=\"ts\">\nconst subscription = observable.subscribe((x) => console.log(x));\n</code-example>\n<p translation-result=\"on\">Subscription 代表正在進行中的執行，並具有允許你取消該執行的最小 API。<a href=\"./guide/subscription\">在此處閱讀有關 <code>Subscription</code> 型別</a>的更多訊息。使用 <code>subscription.unsubscribe()</code> 你可以取消正在進行的執行：</p><p translation-origin=\"off\">The Subscription represents the ongoing execution, and has a minimal API which allows you to cancel that execution. Read more about the <a href=\"./guide/subscription\"><code>Subscription</code> type here</a>. With <code>subscription.unsubscribe()</code> you can cancel the ongoing execution:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = <a href=\"api/index/function/from\" class=\"code-anchor\">from</a>([10, 20, 30]);\nconst subscription = observable.subscribe((x) => console.log(x));\n// Later:\nsubscription.unsubscribe();\n</code-example>\n<p translation-result=\"on\"><span class=\"informal\">當你訂閱時，你會得到一個 Subscription，它代表正在進行的執行。只需呼叫 <code>unsubscribe()</code> 即可取消執行。</span></p><p translation-origin=\"off\"><span class=\"informal\">When you subscribe, you get back a Subscription, which represents the ongoing execution. Just call <code>unsubscribe()</code> to cancel the execution.</span></p>\n\n<p translation-result=\"on\">當我們使用 <code>create()</code> 建立 Observable 時，每個 Observable 都必須定義如何處理該執行的資源。你可以透過從 <code>function subscribe()</code> 中回傳自定義 <code>unsubscribe</code> 函式來做到這一點。</p><p translation-origin=\"off\">Each Observable must define how to dispose resources of that execution when we create the Observable using <code>create()</code>. You can do that by returning a custom <code>unsubscribe</code> function from within <code>function subscribe()</code>.</p>\n\n<p translation-result=\"on\">例如，這就是我們使用 <code>setInterval</code> 清除定時執行集的方式：</p><p translation-origin=\"off\">For instance, this is how we clear an interval execution set with <code>setInterval</code>:</p>\n\n<code-example language=\"js\">\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe(subscriber) {\n  // Keep track <a href=\"api/index/function/of\" class=\"code-anchor\">of</a> the <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a> resource\n  const intervalId = setInterval(() => {\n    subscriber.next('hi');\n  }, 1000);\n\n  // Provide a way <a href=\"api/index/function/of\" class=\"code-anchor\">of</a> canceling and disposing the <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a> resource\n  return function unsubscribe() {\n    clearInterval(intervalId);\n  };\n});\n</code-example>\n<p translation-result=\"on\">就像 <code>observable.subscribe</code> 效仿了 <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe() {...})</code> 一樣，我們從 <code>subscribe</code> 回傳的 <code>unsubscribe</code> 在概念上也相當於 <code>subscription.unsubscribe</code>。事實上，如果我們刪除圍繞這些概念的 ReactiveX 型別，我們就會得到相當簡單的 JavaScript。</p><p translation-origin=\"off\">Just like <code>observable.subscribe</code> resembles <code>new <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>(function subscribe() {...})</code>, the <code>unsubscribe</code> we return from <code>subscribe</code> is conceptually equal to <code>subscription.unsubscribe</code>. In fact, if we remove the ReactiveX types surrounding these concepts, we're left with rather straightforward JavaScript.</p>\n\n<code-example language=\"js\">\nfunction subscribe(subscriber) {\n  const intervalId = setInterval(() => {\n    subscriber.next('hi');\n  }, 1000);\n\n  return function unsubscribe() {\n    clearInterval(intervalId);\n  };\n}\n\nconst unsubscribe = subscribe({ next: (x) => console.log(x) });\n\n// Later:\nunsubscribe(); // dispose the resources\n</code-example>\n<p translation-result=\"on\">我們使用諸如 Observable、Observer 和 Subscription 之類的 Rx 型別的原因是為了獲得安全性（例如 Observable Contract）以及與 Operators 的可組合性。</p><p translation-origin=\"off\">The reason why we use Rx types like Observable, Observer, and Subscription is to get safety (such as the Observable Contract) and composability with Operators.</p>\n\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - ./guide/subscription\n - /api/index/class/Observable\n - /deprecations/to-promise\n - api/index/class/Observable\n - api/index/class/Subscription\n - api/index/const/observable\n - api/index/function/from\n - api/index/function/interval\n - api/index/function/never\n - api/index/function/of\n - guide/observable#anatomy-of-an-observable\n - guide/observable#creating-observables\n - guide/observable#disposing-observable-executions\n - guide/observable#executing-observables\n - guide/observable#observable\n - guide/observable#observables-as-generalizations-of-functions\n - guide/observable#observable（observable）\n - guide/observable#pull-versus-push\n - guide/observable#subscribing-to-observables\n - https://developer.mozilla.org/en-US/docs/Glossary/Function\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*\n-->"
}