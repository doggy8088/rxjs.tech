{
  "id": "guide/testing/marble-testing",
  "title": "",
  "contents": "\n<div class=\"content\">\n<h1 id=\"testing-rxjs-code-with-marble-diagrams\" translation-result=\"on\">用彈珠圖測試 RxJS 程式碼<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#testing-rxjs-code-with-marble-diagrams\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"testing-rxjs-code-with-marble-diagrams\">Testing RxJS Code with Marble Diagrams<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#testing-rxjs-code-with-marble-diagrams\"><i class=\"material-icons\">link</i></a></h1>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><span>本指南講了在使用新的 <code>testScheduler.run(callback)</code> 時彈珠圖的用法。這裡的一些細節不適合手動使用 TestScheduler（不借助 <code>run()</code> 輔助器）。</span></p><p translation-origin=\"off\"><span>This guide refers to usage of marble diagrams when using the new <code>testScheduler.run(callback)</code>. Some details here do not apply to using the TestScheduler manually, without using the <code>run()</code> helper.</span></p>\n\n</div>\n<p translation-result=\"on\">我們可以透過使用 TestScheduler 虛擬化時間來<em>同步</em>並以確定性的方式測試我們的<em>非同步</em> RxJS 程式碼。<strong>彈珠圖</strong>為我們提供了一種視覺化的方式來表示 Observable 的行為。我們可以使用它們來斷言特定的 Observable 的行為符合預期，以及建立一些可以用作模擬（mock）的<a href=\"https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\">冷或熱 Observable</a>。</p><p translation-origin=\"off\">We can test our <em>asynchronous</em> RxJS code <em>synchronously</em> and deterministically by virtualizing time using the TestScheduler. <strong>Marble diagrams</strong> provide a visual way for us to represent the behavior of an Observable. We can use them to assert that a particular Observable behaves as expected, as well as to create <a href=\"https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\">hot and cold Observables</a> we can use as mocks.</p>\n\n<blockquote>\n<p translation-result=\"on\">此時，TestScheduler 只能用於測試使用了 RxJS 排程器 - <code>AsyncScheduler</code> 等的程式碼。例如，如果程式碼使用 Promise，則無法使用 <code><a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a></code> 可靠地進行測試，而應該用更傳統地方式進行測試。有關更多詳細訊息，請參閱<a href=\"guide/testing/marble-testing#known-issues\">已知問題</a>部分。</p><p translation-origin=\"off\">At this time, the TestScheduler can only be used to test code that uses RxJS schedulers - <code>AsyncScheduler</code>, etc. If the code consumes a Promise, for example, it cannot be reliably tested with <code><a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a></code>, but instead should be tested more traditionally. See the <a href=\"guide/testing/marble-testing#known-issues\">Known Issues</a> section for more details.</p>\n\n</blockquote>\n<code-example language=\"ts\">\nimport { <a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs/testing';\nimport { <a href=\"api/index/function/throttleTime\" class=\"code-anchor\">throttleTime</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst testScheduler = new <a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a>((actual, expected) => {\n  // asserting the two objects are equal - required\n  // for <a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a> assertions to work via your test framework\n  // e.g. <a href=\"api/index/function/using\" class=\"code-anchor\">using</a> chai.\n  expect(actual).deep.equal(expected);\n});\n\n// This test runs synchronously.\nit('generates the stream correctly', () => {\n  testScheduler.run((helpers) => {\n    const { cold, time, expectObservable, expectSubscriptions } = helpers;\n    const e1 = cold(' -a--b--c---|');\n    const e1subs = '  ^----------!';\n    const t = time('   ---|       '); // t = 3\n    const expected = '-a-----c---|';\n\n    expectObservable(e1.pipe(<a href=\"api/index/function/throttleTime\" class=\"code-anchor\">throttleTime</a>(t))).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n  });\n});\n</code-example>\n<h2 id=\"api\">API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#api\"><i class=\"material-icons\">link</i></a></h2>\n<p translation-result=\"on\">你提供給 <code>testScheduler.run(callback)</code> 的回呼函式是使用 <code>helpers</code> 物件呼叫的，該物件包含你將用於編寫測試的函式。</p><p translation-origin=\"off\">The callback function you provide to <code>testScheduler.run(callback)</code> is called with <code>helpers</code> object that contains functions you'll use to write your tests.</p>\n\n<div class=\"alert is-helpful\">\n  <span>\n    When the code inside this callback is being executed, any operator that uses timers/AsyncScheduler (like delay, debounceTime, etc.,) will automatically use the TestScheduler instead, so that we have \"virtual time\". You do not need to pass the TestScheduler to them, like in the past.\n  </span>\n</div>\n<code-example language=\"ts\">\ntestScheduler.run((helpers) => {\n  const { cold, hot, expectObservable, expectSubscriptions, flush, time, animate } = helpers;\n  // use them\n});\n</code-example>\n<p translation-result=\"on\">儘管 <code>run()</code> 完全同步執行，但回呼函式中的輔助函式卻不是這樣！這些函式會<strong>排程斷言</strong>，這些斷言將在你的回呼完成或你顯式呼叫 <code>flush()</code> 時執行。在回呼中從你選擇的測試庫中呼叫同步斷言時（例如 <code>expect</code>）要多加小心。有關如何執行此操作的更多訊息，請參閱<a href=\"guide/testing/marble-testing#synchronous-assertion\">同步斷言</a>。</p><p translation-origin=\"off\">Although <code>run()</code> executes entirely synchronously, the helper functions inside your callback function do not! These functions <strong>schedule assertions</strong> that will execute either when your callback completes or when you explicitly call <code>flush()</code>. Be wary of calling synchronous assertions, for example <code>expect</code>, from your testing library of choice, from within the callback. See <a href=\"guide/testing/marble-testing#synchronous-assertion\">Synchronous Assertion</a> for more information on how to do this.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>cold(marbleDiagram: string, values?: object, error?: any)</code> - 建立一個 \"冷的\" observable，它的訂閱在測試開始時開始。</p><p translation-origin=\"off\"><code>cold(marbleDiagram: string, values?: object, error?: any)</code> - creates a \"cold\" observable whose subscription starts when the test begins.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>hot(marbleDiagram: string, values?: object, error?: any)</code> - 建立一個『熱的』 observable（比如主體 Subject），當測試開始時，它的行為就像它已經『在執行』了一樣。一個有趣的區別是 <code>hot</code> 彈珠允許用 <code>^</code> 字元表示『零幀』在哪裡。這就是訂閱被測試的 observables 的開始。</p><p translation-origin=\"off\"><code>hot(marbleDiagram: string, values?: object, error?: any)</code> - creates a \"hot\" observable (like a subject) that will behave as though it's already \"running\" when the test begins. An interesting difference is that <code>hot</code> marbles allow a <code>^</code> character to signal where the \"zero frame\" is. That is the point at which the subscription to observables being tested begins.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>expectObservable(actual: <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>&#x3C;T>, subscriptionMarbles?: string).toBe(marbleDiagram: string, values?: object, error?: any)</code> - 當 TestScheduler 重新整理時安排一個斷言。透過 <code>subscriptionMarbles</code> 引數來改變訂閱和退訂的時間表。如果你不提供 <code>subscriptionMarbles</code> 引數，它將在開始時訂閱並且永遠不會退訂。閱讀以下有關訂閱彈珠圖的訊息。</p><p translation-origin=\"off\"><code>expectObservable(actual: <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>&#x3C;T>, subscriptionMarbles?: string).toBe(marbleDiagram: string, values?: object, error?: any)</code> - schedules an assertion for when the TestScheduler flushes. Give <code>subscriptionMarbles</code> as parameter to change the schedule of subscription and unsubscription. If you don't provide the <code>subscriptionMarbles</code> parameter it will subscribe at the beginning and never unsubscribe. Read below about subscription marble diagram.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]).toBe(subscriptionMarbles: string)</code> - 像 <code>expectObservable</code> 一樣，當 testScheduler 重新整理時安排一個斷言。<code>cold()</code> 和 <code>hot()</code> 都回傳一個帶有 <code>subscriptions</code> 屬性的 observable，其型別為 <code>SubscriptionLog[]</code>。將 <code>subscriptions</code> 作為引數提供給 <code>expectSubscriptions</code> 以斷言它是否與 <code>toBe()</code> 中給出的 <code>subscriptionsMarbles</code> 彈珠圖對應。訂閱彈珠圖與 Observable 彈珠圖略有不同。在下面閱讀更多內容。</p><p translation-origin=\"off\"><code>expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]).toBe(subscriptionMarbles: string)</code> - like <code>expectObservable</code> schedules an assertion for when the testScheduler flushes. Both <code>cold()</code> and <code>hot()</code> return an observable with a property <code>subscriptions</code> of type <code>SubscriptionLog[]</code>. Give <code>subscriptions</code> as parameter to <code>expectSubscriptions</code> to assert whether it matches the <code>subscriptionsMarbles</code> marble diagram given in <code>toBe()</code>. Subscription marble diagrams are slightly different than Observable\nmarble diagrams. Read more below.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>flush()</code> - 立即開始虛擬時間。不經常使用，因為當你的回呼回傳時 <code>run()</code> 會自動為你重新整理，但在某些情況下，你可能希望多次重新整理或以其它方式取得更多控制權。</p><p translation-origin=\"off\"><code>flush()</code> - immediately starts virtual time. Not often used since <code>run()</code> will automatically flush for you when your callback returns, but in some cases you may wish to flush more than once or otherwise have more control.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>time()</code> - 將彈珠轉換為表示幀數的數字。期望指定超時時間的運算子可以使用它。它根據完成訊號 ( <code>|</code> ) 的位置測量時間：</p><p translation-origin=\"off\"><code>time()</code> - converts marbles into a number indicating number of frames. It can be used by operators expecting a specific timeout. It measures time based on the position of the complete (<code>|</code>) signal:</p>\n\n<code-example language=\"ts\">\ntestScheduler.run((helpers) => {\n  const { time, cold } = helpers;\n  const source = cold('---a--b--|');\n  const t = time('        --|    ');\n  //                         --|\n  const expected = '   -----a--b|';\n  const result = source.pipe(<a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a>(t));\n  expectObservable(result).toBe(expected);\n});\n</code-example>\n</li>\n<li>\n<p translation-result=\"on\"><code>animate()</code> - 指定何時『繪製』所請求的動畫幀。<code>animate</code> 接受一個彈珠圖，圖中的每個值在發出時都會指示何時發生『繪製』 - 屆時，將執行任何已排隊的 <code>requestAnimationFrame</code> 回呼。在測試開始時調用 <code>animate</code> 並對齊彈珠圖，以便清楚何時執行回呼：</p><p translation-origin=\"off\"><code>animate()</code> - specifies when requested animation frames will be 'painted'. <code>animate</code> accepts a marble diagram and each value emission in the diagram indicates when a 'paint' occurs - at which time, any queued <code>requestAnimationFrame</code> callbacks will be executed. Call <code>animate</code> at the beginning of your test and align the marble diagrams so that it's clear when the callbacks will be executed:</p>\n\n<code-example language=\"ts\">\ntestScheduler.run((helpers) => {\n  const { animate, cold } = helpers;\n  animate('              ---x---x---x---x');\n  const requests = cold('-r-------r------');\n  /* ... */\n  const expected = '     ---a-------b----';\n});\n</code-example>\n</li>\n</ul>\n<h2 id=\"marble-syntax\" translation-result=\"on\">彈珠語法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#marble-syntax\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"marble-syntax\">Marble syntax<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#marble-syntax\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在 TestScheduler 的上下文中，彈珠圖是一個字串，其中包含表示隨著虛擬時間發生的事件的特殊語法。時間會按<em>幀</em>前進。任何彈珠字串的第一個字元總是代表<em>零幀</em>或者說時間的起點。在 <code>testScheduler.run(callback)</code> 內部，frameTimeFactor 設定為 1，這意味著一幀等於一個虛擬毫秒。</p><p translation-origin=\"off\">In the context of TestScheduler, a marble diagram is a string containing special syntax representing events happening over virtual time. Time progresses by <em>frames</em>. The first character of any marble string always represents the <em>zero frame</em>, or the start of time. Inside of <code>testScheduler.run(callback)</code> the frameTimeFactor is set to 1, which means one frame is equal to one virtual millisecond.</p>\n\n<p translation-result=\"on\">一幀代表多少虛擬毫秒取決於 <code><a href=\"api/testing/TestScheduler#frameTimeFactor\" class=\"code-anchor\">TestScheduler.frameTimeFactor</a></code> 的值。由於遺留原因，<em>只有</em>當 <code>testScheduler.run(callback)</code> 回呼中的程式碼正在執行時，<code>frameTimeFactor</code> 的值才為 1。在此之外，它設定為 10。這一點可能會在 RxJS 的未來版本中發生變化，以便讓它始終為 1。</p><p translation-origin=\"off\">How many virtual milliseconds one frame represents depends on the value of <code><a href=\"api/testing/TestScheduler#frameTimeFactor\" class=\"code-anchor\">TestScheduler.frameTimeFactor</a></code>. For legacy reasons the value of <code>frameTimeFactor</code> is 1 <em>only</em> when your code inside the <code>testScheduler.run(callback)</code> callback is running. Outside of it, it's set to 10. This will likely change in a future version of RxJS so that it is always 1.</p>\n\n<blockquote>\n<p translation-result=\"on\">重要提示：本語法指南是指在使用新的 <code>testScheduler.run(callback)</code> 時使用彈珠圖。手動使用 TestScheduler 時彈珠圖的語義不同，並且不支援新的時間進度語法等某些功能。</p><p translation-origin=\"off\">IMPORTANT: This syntax guide refers to usage of marble diagrams when using the new <code>testScheduler.run(callback)</code>. The semantics of marble diagrams when using the TestScheduler manually are different, and some features like the new time progression syntax are not supported.</p>\n\n</blockquote>\n<ul>\n<li>\n<p translation-result=\"on\"><code>' '</code> 空白：忽略水平空白，可用於幫助垂直對齊多個彈珠圖。</p><p translation-origin=\"off\"><code>' '</code> whitespace: horizontal whitespace is ignored, and can be used to help vertically align multiple marble diagrams.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>'-'</code> 幀：1 個虛擬時間流逝的『幀』（參見上面的幀描述）。</p><p translation-origin=\"off\"><code>'-'</code> frame: 1 \"frame\" of virtual time passing (see above description of frames).</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>[0-9]+[ms|s|m]</code> 時間進度：時間進度語法允許你將虛擬時間推進特定的數量。它是一個數字，後跟 <code>ms</code>（毫秒）、<code>s</code>（秒）或 <code>m</code>（分鐘）的時間單位，它們之間沒有任何空格，例如 <code>a 10ms b</code>。有關更多詳細訊息，請參閱<a href=\"guide/testing/marble-testing#time-progression-syntax\">時間進度語法</a>。</p><p translation-origin=\"off\"><code>[0-9]+[ms|s|m]</code> time progression: the time progression syntax lets you progress virtual time by a specific amount. It's a number, followed by a time unit of <code>ms</code> (milliseconds), <code>s</code> (seconds), or <code>m</code> (minutes) without any space between them, e.g. <code>a 10ms b</code>. See <a href=\"guide/testing/marble-testing#time-progression-syntax\">Time progression syntax</a> for more details.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>'|'</code> 完成：一個 Observable 的成功完成。這是 Observable 的生產者訊號 <code>complete()</code>。</p><p translation-origin=\"off\"><code>'|'</code> complete: The successful completion of an observable. This is the observable producer signaling <code>complete()</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>'#'</code> 錯誤：終止 observable 的錯誤。這是 Observable 的生產者訊號 <code>error()</code>。</p><p translation-origin=\"off\"><code>'#'</code> error: An error terminating the observable. This is the observable producer signaling <code>error()</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>[a-z0-9]</code>（例如 <code>'a'</code>）任何字母數字字元：表示由生產者訊號 <code>next()</code> 發出的值。你可以將它對映到一個物件或陣列中，如下所示：</p><p translation-origin=\"off\"><code>[a-z0-9]</code> e.g. <code>'a'</code> any alphanumeric character: Represents a value being emitted by the producer signaling <code>next()</code>. Also consider that you could map this into an object or an array like this:</p>\n\n</li>\n</ul>\n<!-- prettier-ignore -->\n<code-example language=\"ts\">\nconst expected = '400ms (a-b|)';\nconst values = {\n  a: 'value emitted',\n  b: 'another value emitted',\n};\n\nexpectObservable(someStreamForTesting).toBe(expected, values);\n\n// This would work also\nconst expected = '400ms (0-1|)';\nconst values = [\n  'value emitted',\n  'another value emitted'\n];\n\nexpectObservable(someStreamForTesting).toBe(expected, values);\n</code-example>\n<ul>\n<li>\n<p translation-result=\"on\"><code>'()'</code> 同步分組：當多個事件需要同步在同一幀中時，括號用於對這些事件進行分組。你可以透過這種方式對下一個值、完成或錯誤進行分組。初始值 <code>(</code> 的位置決定了它的值被髮出的時間。雖然一開始有點反直覺，但在所有值同步發出後，時間將前進的幀數等於組中的 ASCII 字元數, 包括括號。例如 <code>'(abc)'</code> 將在同一幀中同步發出 a、b 和 c 的值，然後將虛擬時間提前 5 幀，<code>'(abc)'.length === 5</code>。這麼做是因為它通常可以幫助你垂直對齊彈珠圖，這是實際測試中的一個已知痛點。<a href=\"guide/testing/marble-testing#known-issues\">瞭解有關已知問題</a>的更多訊息。</p><p translation-origin=\"off\"><code>'()'</code> sync groupings: When multiple events need to be in the same frame synchronously, parentheses are used to group those events. You can group next'd values, a completion, or an error in this manner. The position of the initial <code>(</code> determines the time at which its values are emitted. While it can be counter-intuitive at first, after all the values have synchronously emitted time will progress a number of frames equal to the number of ASCII characters in the group, including the parentheses.\ne.g. <code>'(abc)'</code> will emit the values of a, b, and c synchronously in the same frame and then advance virtual time by 5 frames, <code>'(abc)'.length === 5</code>. This is done because it often helps you vertically align your marble diagrams, but it's a known pain point in real-world testing. <a href=\"guide/testing/marble-testing#known-issues\">Learn more about known issues</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>'^'</code> 訂閱點：（僅限熱的 observables）顯示被測試的 observables 將訂閱熱 observable 的時間點。這是該 Observable 的『零幀』，<code>^</code> 之前的每一幀都是負數。負時間可能看起來毫無意義，但實際上在高階情況下這是必要的，這通常和 ReplaySubject 有關。</p><p translation-origin=\"off\"><code>'^'</code> subscription point: (hot observables only) shows the point at which the tested observables will be subscribed to the hot observable. This is the \"zero frame\" for that observable, every frame before the <code>^</code> will be negative. Negative time might seem pointless, but there are in fact advanced cases where this is necessary, usually involving ReplaySubjects.</p>\n\n</li>\n</ul>\n<h3 id=\"time-progression-syntax\" translation-result=\"on\">時間進展語法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#time-progression-syntax\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"time-progression-syntax\">Time progression syntax<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#time-progression-syntax\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">新的時間進度語法是從 CSS 持續時間語法中汲取的靈感。它是一個數字（整數或浮點數），後面緊跟一個單位：ms（毫秒）、s（秒）、m（分鐘）。例如 <code>100ms</code>、<code>1.4s</code>、<code>5.25m</code>。</p><p translation-origin=\"off\">The new time progression syntax takes inspiration from the CSS duration syntax. It's a number (integer or floating point) immediately followed by a unit; ms (milliseconds), s (seconds), m (minutes). e.g. <code>100ms</code>, <code>1.4s</code>, <code>5.25m</code>.</p>\n\n<p translation-result=\"on\">當它不是圖表的第一個字元時，必須在之前/之後填充一個空格，以消除它與一系列彈珠的歧義。例如 <code>a 1ms b</code> 需要空格，因為 <code>a1msb</code> 將被解釋為 <code>['a', '1', 'm', 's', 'b']</code> 其中每個字元都是 next() 的原樣值。</p><p translation-origin=\"off\">When it's not the first character of the diagram it must be padded a space before/after to disambiguate it from a series of marbles. e.g. <code>a 1ms b</code> needs the spaces because <code>a1msb</code> will be interpreted as <code>['a', '1', 'm', 's', 'b']</code> where each of these characters is a value that will be next()'d as-is.</p>\n\n<p translation-result=\"on\"><strong>注意</strong>：你可能需要從你想要前進的時間中減去 1 毫秒，因為字母數字彈珠（代表實際發出的值）在它們發出後自身已經<em>提前了 1 個虛擬幀</em>。這可能是反直覺和令人沮喪的，但目前它確實是正確的。</p><p translation-origin=\"off\"><strong>NOTE</strong>: You may have to subtract 1 millisecond from the time you want to progress because the alphanumeric marbles (representing an actual emitted value) <em>advance time 1 virtual frame</em> themselves already, after they emit. This can be counter-intuitive and frustrating, but for now it is indeed correct.</p>\n\n<!-- prettier-ignore -->\n<code-example language=\"ts\">\nconst input = ' -a-b-c|';\nconst expected = '-- 9ms a 9ms b 9ms (c|)';\n\n// Depending on your personal preferences you could also\n// use frame dashes to keep vertical alignment with the input.\n// const input = ' -a-b-c|';\n// const expected = '------- 4ms a 9ms b 9ms (c|)';\n// or\n// const expected = '-----------a 9ms b 9ms (c|)';\n\nconst result = cold(input).pipe(\n  <a href=\"api/index/function/concatMap\" class=\"code-anchor\">concatMap</a>((d) => <a href=\"api/index/function/of\" class=\"code-anchor\">of</a>(d).pipe(\n    <a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a>(10)\n  ))\n);\n\nexpectObservable(result).toBe(expected);\n</code-example>\n<h3 id=\"examples\" translation-result=\"on\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#examples\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"examples\">Examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#examples\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>'-'</code> 或 <code>'------'</code> ：等價於 <a href=\"api/index/const/NEVER\"><code>NEVER</code></a>，或者是一個『從不發出』、『錯誤』或『完成』的 Observable。</p><p translation-origin=\"off\"><code>'-'</code> or <code>'------'</code>: Equivalent to <a href=\"api/index/const/NEVER\"><code>NEVER</code></a>, or an observable that never emits or errors or completes.</p>\n\n<p translation-result=\"on\"><code>|</code> : 等價於 <a href=\"api/index/const/EMPTY\"><code>EMPTY</code></a>，或者是一個永遠不會立即發出和完成的 observable。</p><p translation-origin=\"off\"><code>|</code>: Equivalent to <a href=\"api/index/const/EMPTY\"><code>EMPTY</code></a>, or an observable that never emits and completes immediately.</p>\n\n<p translation-result=\"on\"><code>#</code> ：等價於 <a href=\"api/index/function/throwError\"><code>throwError</code></a>，或者是一個永遠不會立即發出錯誤的 Observable。</p><p translation-origin=\"off\"><code>#</code>: Equivalent to <a href=\"api/index/function/throwError\"><code>throwError</code></a>, or an observable that never emits and errors immediately.</p>\n\n<p translation-result=\"on\"><code>'--a--'</code> ：一個等待 2 個『幀』的 Observable，在第 2 幀上發出值 <code>a</code> 然後永遠不會完成。</p><p translation-origin=\"off\"><code>'--a--'</code>: An observable that waits 2 \"frames\", emits value <code>a</code> on frame 2 and then never completes.</p>\n\n<p translation-result=\"on\"><code>'--a--b--|'</code> ：在第 2 幀發出 <code>a</code>，在第 5 幀發出 <code>b</code>，在第 8 幀 <code>complete</code>。</p><p translation-origin=\"off\"><code>'--a--b--|'</code>: On frame 2 emit <code>a</code>, on frame 5 emit <code>b</code>, and on frame 8, <code>complete</code>.</p>\n\n<p translation-result=\"on\"><code>'--a--b--#'</code> ：在第 2 幀發出 <code>a</code>，在第 5 幀發出 <code>b</code>，在第 8 幀發出 <code>error</code>。</p><p translation-origin=\"off\"><code>'--a--b--#'</code>: On frame 2 emit <code>a</code>, on frame 5 emit <code>b</code>, and on frame 8, <code>error</code>.</p>\n\n<p translation-result=\"on\"><code>'-a-^-b--|'</code> ：在一個熱 observable 中，在 -2 幀上發出 <code>a</code>，然後在第 2 幀上發出 <code>b</code>，在第 5 幀上 <code>complete</code>。</p><p translation-origin=\"off\"><code>'-a-^-b--|'</code>: In a hot observable, on frame -2 emit <code>a</code>, then on frame 2 emit <code>b</code>, and on frame 5, <code>complete</code>.</p>\n\n<p translation-result=\"on\"><code>'--(abc)-|'</code> ：在第 2 幀發出 <code>a</code>、<code>b</code> 和 <code>c</code>，然後在第 8 幀，<code>complete</code>。</p><p translation-origin=\"off\"><code>'--(abc)-|'</code>: on frame 2 emit <code>a</code>, <code>b</code>, and <code>c</code>, then on frame 8, <code>complete</code>.</p>\n\n<p translation-result=\"on\"><code>'-----(a|)'</code> ：在第 5 幀發出 <code>a</code> 並 <code>complete</code>。</p><p translation-origin=\"off\"><code>'-----(a|)'</code>: on frame 5 emit <code>a</code> and <code>complete</code>.</p>\n\n<p translation-result=\"on\"><code>'a 9ms b 9s c|'</code> ：在第 0 幀發出 <code>a</code>，在第 10 幀發出 <code>b</code>，在第 9,011 幀發出 <code>c</code>，然後在第 9,012 幀 <code>complete</code>。</p><p translation-origin=\"off\"><code>'a 9ms b 9s c|'</code>: on frame 0 emit <code>a</code>, on frame 10 emit <code>b</code>, on frame 9,011 emit <code>c</code>, then on frame 9,012 <code>complete</code>.</p>\n\n<p translation-result=\"on\"><code>'--a 2.5m b'</code> ：在第 2 幀發出 <code>a</code>，在第 150,003 幀發出 <code>b</code> 並且永遠不會完成。</p><p translation-origin=\"off\"><code>'--a 2.5m b'</code>: on frame 2 emit <code>a</code>, on frame 150,003 emit <code>b</code> and never complete.</p>\n\n<h2 id=\"subscription-marbles\" translation-result=\"on\">訂閱彈珠<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#subscription-marbles\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"subscription-marbles\">Subscription marbles<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#subscription-marbles\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code>expectSubscriptions</code> 幫助器允許你斷言所建立的 <code>cold()</code> 或 <code>hot()</code> Observable 會在正確的時間點被訂閱/退訂。<code>expectObservable</code> 的 <code>subscriptionMarbles</code> 引數允許你的測試將訂閱推遲到以後的虛擬時間，和/或退訂，即使正在測試的 observable 尚未完成。</p><p translation-origin=\"off\">The <code>expectSubscriptions</code> helper allows you to assert that a <code>cold()</code> or <code>hot()</code> Observable you created was subscribed/unsubscribed to at the correct point in time. The <code>subscriptionMarbles</code> parameter to <code>expectObservable</code> allows your test to defer subscription to a later virtual time, and/or unsubscribe even if the observable being tested has not yet completed.</p>\n\n<p translation-result=\"on\">訂閱彈珠語法與傳統彈珠語法略有不同。</p><p translation-origin=\"off\">The subscription marble syntax is slightly different to conventional marble syntax.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>'-'</code> 時間：1 幀時間過去。</p><p translation-origin=\"off\"><code>'-'</code> time: 1 frame time passing.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>[0-9]+[ms|s|m]</code> 時間進度：時間進度語法允許你將虛擬時間推進特定數量。它是一個數字，後跟 <code>ms</code>（毫秒）、<code>s</code>（秒）或 <code>m</code>（分鐘）的時間單位，它們之間沒有任何空格，例如 <code>a 10ms b</code>。有關更多詳細訊息，請參閱<a href=\"guide/testing/marble-testing#time-progression-syntax\">時間進度語法</a>。</p><p translation-origin=\"off\"><code>[0-9]+[ms|s|m]</code> time progression: the time progression syntax lets you progress virtual time by a specific amount. It's a number, followed by a time unit of <code>ms</code> (milliseconds), <code>s</code> (seconds), or <code>m</code> (minutes) without any space between them, e.g. <code>a 10ms b</code>. See <a href=\"guide/testing/marble-testing#time-progression-syntax\">Time progression syntax</a> for more details.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>'^'</code> 訂閱點：顯示訂閱發生的時間點。</p><p translation-origin=\"off\"><code>'^'</code> subscription point: shows the point in time at which a subscription happens.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>'!'</code> 退訂點：顯示退訂的時間點。</p><p translation-origin=\"off\"><code>'!'</code> unsubscription point: shows the point in time at which a subscription is unsubscribed.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">訂閱彈珠圖<strong>中應該最多有一個</strong> <code>^</code> 點，<strong>最多有一個</strong> <code>!</code> 點。除此之外，<code>-</code> 字元是訂閱彈珠圖中唯一允許的字元。</p><p translation-origin=\"off\">There should be <strong>at most one</strong> <code>^</code> point in a subscription marble diagram, and <strong>at most one</strong> <code>!</code> point. Other than that, the <code>-</code> character is the only one allowed in a subscription marble diagram.</p>\n\n<h3 id=\"examples-1\" translation-result=\"on\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#examples-1\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"examples-1\">Examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#examples-1\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>'-'</code> 或 <code>'------'</code> ：從未發生過訂閱。</p><p translation-origin=\"off\"><code>'-'</code> or <code>'------'</code>: no subscription ever happened.</p>\n\n<p translation-result=\"on\"><code>'--^--'</code> ：訂閱發生在 2 『幀』時間過去後，並且此訂閱沒有退訂。</p><p translation-origin=\"off\"><code>'--^--'</code>: a subscription happened after 2 \"frames\" of time passed, and the subscription was not unsubscribed.</p>\n\n<p translation-result=\"on\"><code>'--^--!-'</code> ：在第 2 幀發生了訂閱，在第 5 幀被取消了訂閱。</p><p translation-origin=\"off\"><code>'--^--!-'</code>: on frame 2 a subscription happened, and on frame 5 was unsubscribed.</p>\n\n<p translation-result=\"on\"><code>'500ms ^ 1s !'</code> ：在第 500 幀發生了訂閱，在第 1,501 幀被取消了訂閱。</p><p translation-origin=\"off\"><code>'500ms ^ 1s !'</code>: on frame 500 a subscription happened, and on frame 1,501 was unsubscribed.</p>\n\n<p translation-result=\"on\">給定一個熱的來源，測試在不同時間訂閱的多個訂閱者：</p><p translation-origin=\"off\">Given a hot source, test multiple subscribers that subscribe at different times:</p>\n\n<code-example language=\"ts\">\ntestScheduler.run(({ hot, expectObservable }) => {\n  const source = hot('--a--a--a--a--a--a--a--');\n  const sub1 = '      --^-----------!';\n  const sub2 = '      ---------^--------!';\n  const expect1 = '   --a--a--a--a--';\n  const expect2 = '   -----------a--a--a-';\n\n  expectObservable(source, sub1).toBe(expect1);\n  expectObservable(source, sub2).toBe(expect2);\n});\n</code-example>\n<p translation-result=\"on\">手動退訂永遠不會完成的源：</p><p translation-origin=\"off\">Manually unsubscribe from a source that will never complete:</p>\n\n<code-example language=\"ts\">\nit('should <a href=\"api/index/function/repeat\" class=\"code-anchor\">repeat</a> forever', () => {\n  const testScheduler = createScheduler();\n\n  testScheduler.run(({ expectObservable }) => {\n    const foreverStream$ = <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>(1).pipe(<a href=\"api/index/function/mapTo\" class=\"code-anchor\">mapTo</a>('a'));\n\n    // Omitting this arg may crash the test suite.\n    const unsub = '------!';\n\n    expectObservable(foreverStream$, unsub).toBe('-aaaaa');\n  });\n});\n</code-example>\n<h2 id=\"synchronous-assertion\" translation-result=\"on\">同步斷言<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#synchronous-assertion\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"synchronous-assertion\">Synchronous Assertion<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#synchronous-assertion\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">有時，我們需要在可觀察流完成<em>之後</em>斷言狀態的變更 - 例如像 <code><a href=\"api/index/function/tap\" class=\"code-anchor\">tap</a></code> 這樣的運算子在副作用中更新了變數時。在使用 TestScheduler 進行彈珠測試之外，我們可能會認為這是在做出斷言之前造成延遲或等待。</p><p translation-origin=\"off\">Sometimes, we need to assert changes in state <em>after</em> an observable stream has completed - such as when a side effect like <code><a href=\"api/index/function/tap\" class=\"code-anchor\">tap</a></code> updates a variable. Outside of Marbles testing with TestScheduler, we might think of this as creating a delay or waiting before making our assertion.</p>\n\n<p translation-result=\"on\">例如：</p><p translation-origin=\"off\">For example:</p>\n\n<code-example language=\"ts\">\nlet eventCount = 0;\n\nconst s1 = cold('--a--b|', { a: 'x', b: 'y' });\n\n// side effect <a href=\"api/index/function/using\" class=\"code-anchor\">using</a> '<a href=\"api/index/function/tap\" class=\"code-anchor\">tap</a>' updates a variable\nconst result = s1.pipe(<a href=\"api/index/function/tap\" class=\"code-anchor\">tap</a>(() => eventCount++));\n\nexpectObservable(result).toBe('--a--b|', { a: 'x', b: 'y' });\n\n// flush - run 'virtual time' to complete all outstanding hot or cold observables\nflush();\n\nexpect(eventCount).toBe(2);\n</code-example>\n<p translation-result=\"on\">在上述情況下，我們需要完成 observable 流，以便我們可以測試變數是否已設定為正確的值。TestScheduler 在『虛擬時間』中（同步）執行，但在 testScheduler 回呼回傳之前通常不會執行（並完成）。flush() 方法會手動觸發虛擬時間，以便我們可以在 observable 完成後測試區域性變數。</p><p translation-origin=\"off\">In the above situation we need the observable stream to complete so that we can test the variable was set to the correct value. The TestScheduler runs in 'virtual time' (synchronously), but doesn't normally run (and complete) until the testScheduler callback returns. The flush() method manually triggers the virtual time so that we can test the local variable after the observable completes.</p>\n\n<hr>\n<h2 id=\"known-issues\" translation-result=\"on\">已知的問題<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#known-issues\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"known-issues\">Known issues<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#known-issues\"><i class=\"material-icons\">link</i></a></h2>\n\n<h3 id=\"rxjs-code-that-consumes-promises-cannot-be-directly-tested\" translation-result=\"on\">使用 Promises 的 RxJS 程式碼無法直接測試<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#rxjs-code-that-consumes-promises-cannot-be-directly-tested\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"rxjs-code-that-consumes-promises-cannot-be-directly-tested\">RxJS code that consumes Promises cannot be directly tested<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#rxjs-code-that-consumes-promises-cannot-be-directly-tested\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果你有使用非同步排程的 RxJS 程式碼（例如 Promises 等）你不能可靠地<em>為那部分程式碼</em>使用彈珠圖。這是因為另外那些排程方法不會被虛擬化或不瞭解 TestScheduler。</p><p translation-origin=\"off\">If you have RxJS code that uses asynchronous scheduling - e.g. Promises, etc. - you can't reliably use marble diagrams <em>for that particular code</em>. This is because those other scheduling methods won't be virtualized or known to TestScheduler.</p>\n\n<p translation-result=\"on\">解決方案是使用測試框架的傳統非同步測試方法單獨測試該程式碼。具體細節取決於你選擇的測試框架，但這裡有一個虛擬碼範例：</p><p translation-origin=\"off\">The solution is to test that code in isolation, with the traditional asynchronous testing methods of your testing framework. The specifics depend on your testing framework of choice, but here's a pseudo-code example:</p>\n\n<code-example language=\"ts\">\n// Some RxJS code that also consumes a Promise, so <a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a> won't be able\n// to correctly virtualize and the test will always be really asynchronous.\nconst myAsyncCode = () => <a href=\"api/index/function/from\" class=\"code-anchor\">from</a>(Promise.resolve('something'));\n\nit('has async code', (done) => {\n  myAsyncCode().subscribe((d) => {\n    assertEqual(d, 'something');\n    done();\n  });\n});\n</code-example>\n<p translation-result=\"on\">一個相關說明：你目前也無法斷言延遲為零，即使用的是 <code>AsyncScheduler</code>，例如 <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a>(0)</code> 也就是 <code>setTimeout(work, 0)</code>。這會安排一個新的<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\">『任務』也叫『巨集任務』</a>，所以它是非同步的，但沒有明確的時間流逝。</p><p translation-origin=\"off\">On a related note, you also can't currently assert delays of zero, even with <code>AsyncScheduler</code>, e.g. <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a>(0)</code> is like saying <code>setTimeout(work, 0)</code>. This schedules a new <a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\">\"task\" aka \"macrotask\"</a>, so it's asynchronous, but without an explicit passage of time.</p>\n\n<h3 id=\"behavior-is-different-outside-of-testschedulerruncallback\" translation-result=\"on\">在 <code>testScheduler.run(callback)</code> 之外的行為有些差異<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#behavior-is-different-outside-of-testschedulerruncallback\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"behavior-is-different-outside-of-testschedulerruncallback\">Behavior is different outside of <code>testScheduler.run(callback)</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#behavior-is-different-outside-of-testschedulerruncallback\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a></code> 從 v5 開始就已經存在，但實際上是供維護人員測試 RxJS 本身準備的，而不是讓普通使用者在應用程式中使用。正因為如此，TestScheduler 的一些預設行為和功能對使用者來說效果不佳（或根本不工作）。在 v6 中，我們引入了 <code>testScheduler.run(callback)</code> 方法，它允許我們以非破壞性的方式提供新的預設值和屬性，但仍然可以在 <code>testScheduler.run(callback)</code> <a href=\"https://github.com/ReactiveX/rxjs/blob/7113ae4b451dd8463fae71b68edab96079d089df/docs_app/content/guide/testing/internal-marble-tests.md\">之外使用 TestScheduler</a>。重要的是要注意，如果你這樣做，它的行為方式會有一些重大差異。</p><p translation-origin=\"off\">The <code><a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a></code> has been around since v5, but was actually intended for testing RxJS itself by the maintainers, rather than for use in regular user apps. Because of this, some of the default behaviors and features of the TestScheduler did not work well (or at all) for users. In v6 we introduced the <code>testScheduler.run(callback)</code> method which allowed us to provide new defaults and features in a non-breaking way, but it's still possible\nto <a href=\"https://github.com/ReactiveX/rxjs/blob/7113ae4b451dd8463fae71b68edab96079d089df/docs_app/content/guide/testing/internal-marble-tests.md\">use the TestScheduler outside</a> of <code>testScheduler.run(callback)</code>. It's important to note that if you do so, there are some major differences in how it will behave.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code><a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a></code> 輔助方法具有更冗長的名稱，例如 <code>testScheduler.createColdObservable()</code> 而不是 <code>cold()</code>。</p><p translation-origin=\"off\"><code><a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a></code> helper methods have more verbose names, like <code>testScheduler.createColdObservable()</code> instead of <code>cold()</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">使用 AsyncScheduler 的運算子<em>不會</em>自動使用 <code>AsyncScheduler</code> 實例，例如 <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code>、<code><a href=\"api/index/function/debounceTime\" class=\"code-anchor\">debounceTime</a></code> 等，因此你必須將其顯式傳遞給它們。</p><p translation-origin=\"off\">The testScheduler instance is <em>not</em> automatically used by operators that use <code>AsyncScheduler</code>, e.g. <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code>, <code><a href=\"api/index/function/debounceTime\" class=\"code-anchor\">debounceTime</a></code>, etc., so you have to explicitly pass it to them.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">不支援時間進度語法，例如 <code>-a 100ms b-|</code> .</p><p translation-origin=\"off\">There is NO support for time progression syntax e.g. <code>-a 100ms b-|</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">1 幀預設為 10 個虛擬毫秒。即 <code><a href=\"api/testing/TestScheduler#frameTimeFactor\" class=\"code-anchor\">TestScheduler.frameTimeFactor</a> = 10</code>。</p><p translation-origin=\"off\">1 frame is 10 virtual milliseconds by default. i.e. <code><a href=\"api/testing/TestScheduler#frameTimeFactor\" class=\"code-anchor\">TestScheduler.frameTimeFactor</a> = 10</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">每個空格 <code>' '</code> 等於 1 幀，與連字元 <code>'-'</code> 相同。</p><p translation-origin=\"off\">Each whitespace <code>' '</code> equals 1 frame, same as a hyphen <code>'-'</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">有一個硬性的最大幀數設定為 750 即 <code>maxFrames = 750</code>。在 750 之後，它們會被默默地忽略。</p><p translation-origin=\"off\">There is a hard maximum number of frames set at 750 i.e. <code>maxFrames = 750</code>. After 750 they are silently ignored.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">你必須顯式重新整理排程器。</p><p translation-origin=\"off\">You must explicitly flush the scheduler.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">雖然此時在 <code>testScheduler.run(callback)</code> 之外使用 TestScheduler 尚未被正式棄用，但不鼓勵這樣做，因為它可能會引起混淆。</p><p translation-origin=\"off\">While at this time usage of the TestScheduler outside of <code>testScheduler.run(callback)</code> has not been officially deprecated, it is discouraged because it is likely to cause confusion.</p>\n\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/index/class/Observable\n - api/index/const/EMPTY\n - api/index/const/NEVER\n - api/index/function/concatMap\n - api/index/function/debounceTime\n - api/index/function/delay\n - api/index/function/from\n - api/index/function/interval\n - api/index/function/mapTo\n - api/index/function/of\n - api/index/function/repeat\n - api/index/function/tap\n - api/index/function/throttleTime\n - api/index/function/throwError\n - api/index/function/using\n - api/testing/TestScheduler\n - api/testing/TestScheduler#frameTimeFactor\n - guide/testing/marble-testing#api\n - guide/testing/marble-testing#behavior-is-different-outside-of-testschedulerruncallback\n - guide/testing/marble-testing#examples\n - guide/testing/marble-testing#examples-1\n - guide/testing/marble-testing#known-issues\n - guide/testing/marble-testing#marble-syntax\n - guide/testing/marble-testing#rxjs-code-that-consumes-promises-cannot-be-directly-tested\n - guide/testing/marble-testing#subscription-marbles\n - guide/testing/marble-testing#synchronous-assertion\n - guide/testing/marble-testing#testing-rxjs-code-with-marble-diagrams\n - guide/testing/marble-testing#time-progression-syntax\n - https://github.com/ReactiveX/rxjs/blob/7113ae4b451dd8463fae71b68edab96079d089df/docs_app/content/guide/testing/internal-marble-tests.md\n - https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n - https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\n-->"
}