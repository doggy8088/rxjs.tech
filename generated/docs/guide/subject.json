{
  "id": "guide/subject",
  "title": "",
  "contents": "\n<div class=\"content\">\n<h1 id=\"subject\" translation-result=\"on\">主體<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#subject\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"subject\">Subject<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#subject\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\"><strong>什麼是主體？</strong> RxJS Subject 是一種特殊型別的 Observable，它允許將值多播到多個 Observer。雖然普通的 Observable 是單播的（每個訂閱的 Observer 都擁有 Observable 的獨立執行），但 Subjects 是多播的。</p><p translation-origin=\"off\"><strong>What is a Subject?</strong> An RxJS Subject is a special type of Observable that allows values to be multicasted to many Observers. While plain Observables are unicast (each subscribed Observer owns an independent execution of the Observable), Subjects are multicast.</p>\n\n<p translation-result=\"on\"><span class=\"informal\">Subject 類似於 Observable，但可以多播到多個 Observer。Subjects 就像 EventEmitters：它們維護著許多監聽器的登錄檔。</span></p><p translation-origin=\"off\"><span class=\"informal\">A Subject is like an Observable, but can multicast to many Observers. Subjects are like EventEmitters: they maintain a registry of many listeners.</span></p>\n\n<p translation-result=\"on\"><strong>每個 Subject 都是 Observable。</strong>給定一個 Subject，你可以 <code>subscribe</code> 它，提供一個 Observer，它將開始正常接收值。從 Observer 的角度來看，它無法判斷 Observable 的執行是來自普通的單播 Observable 還是來自 Subject。</p><p translation-origin=\"off\"><strong>Every Subject is an Observable.</strong> Given a Subject, you can <code>subscribe</code> to it, providing an Observer, which will start receiving values normally. From the perspective of the Observer, it cannot tell whether the Observable execution is coming from a plain unicast Observable or a Subject.</p>\n\n<p translation-result=\"on\">在 Subject 內部，<code>subscribe</code> 不會呼叫一次能給出值的新執行過程。它只是在一個 Observer 清單中註冊給定的 Observer，類似於 <code>addListener</code> 通常在其它函式庫和語言中的工作方式。</p><p translation-origin=\"off\">Internally to the Subject, <code>subscribe</code> does not invoke a new execution that delivers values. It simply registers the given Observer in a list of Observers, similarly to how <code>addListener</code> usually works in other libraries and languages.</p>\n\n<p translation-result=\"on\"><strong>每個 Subject 也都是 Observer。</strong>它是一個具有方法 <code>next(v)</code>、<code>error(e)</code> 和 <code>complete()</code> 的物件。要為 Subject 提供一個新值，只需呼叫 <code>next(theValue)</code>，它將被多播到註冊進來監聽 Subject 的 Observer。</p><p translation-origin=\"off\"><strong>Every Subject is an Observer.</strong> It is an object with the methods <code>next(v)</code>, <code>error(e)</code>, and <code>complete()</code>. To feed a new value to the Subject, just call <code>next(theValue)</code>, and it will be multicasted to the Observers registered to listen to the Subject.</p>\n\n<p translation-result=\"on\">在下面的範例中，我們有兩個 Observer 附加到一個主體，我們向這個主體提供一些值：</p><p translation-origin=\"off\">In the example below, we have two Observers attached to a Subject, and we feed some values to the Subject:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst subject = new <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;number>();\n\nsubject.subscribe({\n  next: (v) => console.log(`observerA: ${v}`),\n});\nsubject.subscribe({\n  next: (v) => console.log(`observerB: ${v}`),\n});\n\nsubject.next(1);\nsubject.next(2);\n\n// Logs:\n// observerA: 1\n// observerB: 1\n// observerA: 2\n// observerB: 2\n</code-example>\n<p translation-result=\"on\">由於 Subject 是 Observer，這也意味著你可以提供 Subject 作為任意 Observable <code>subscribe</code> 的引數，如下麵的範例所示：</p><p translation-origin=\"off\">Since a Subject is an Observer, this also means you may provide a Subject as the argument to the <code>subscribe</code> of any Observable, like the example below shows:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>, <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst subject = new <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;number>();\n\nsubject.subscribe({\n  next: (v) => console.log(`observerA: ${v}`),\n});\nsubject.subscribe({\n  next: (v) => console.log(`observerB: ${v}`),\n});\n\nconst <a href=\"api/index/const/observable\" class=\"code-anchor\">observable</a> = <a href=\"api/index/function/from\" class=\"code-anchor\">from</a>([1, 2, 3]);\n\nobservable.subscribe(subject); // You can subscribe providing a <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>\n\n// Logs:\n// observerA: 1\n// observerB: 1\n// observerA: 2\n// observerB: 2\n// observerA: 3\n// observerB: 3\n</code-example>\n<p translation-result=\"on\">使用上述方法，我們基本上只是透過 Subject 將單播 Observable 執行轉換為多播。這展示了 Subjects 是讓任何 Observable 執行共享給多個 Observers 的唯一方法。</p><p translation-origin=\"off\">With the approach above, we essentially just converted a unicast Observable execution to multicast, through the Subject. This demonstrates how Subjects are the only way of making any Observable execution be shared to multiple Observers.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a></code> 型別還有一些特化： <code><a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a></code>、<code><a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a></code> 和 <code><a href=\"api/index/class/AsyncSubject\" class=\"code-anchor\">AsyncSubject</a></code>。</p><p translation-origin=\"off\">There are also a few specializations of the <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a></code> type: <code><a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a></code>, <code><a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a></code>, and <code><a href=\"api/index/class/AsyncSubject\" class=\"code-anchor\">AsyncSubject</a></code>.</p>\n\n<h2 id=\"multicasted-observables\" translation-result=\"on\">多播 Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#multicasted-observables\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"multicasted-observables\">Multicasted Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#multicasted-observables\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">『多播 Observable』透過可能有許多訂閱者的 Subject 來傳遞通知，而普通的『單播 Observable』僅向單個 Observer 傳送通知。</p><p translation-origin=\"off\">A \"multicasted Observable\" passes notifications through a Subject which may have many subscribers, whereas a plain \"unicast Observable\" only sends notifications to a single Observer.</p>\n\n<p translation-result=\"on\"><span class=\"informal\">多播的 Observable 在底層使用 Subject 來讓多個 Observer 看到相同的 Observable 執行過程。</span></p><p translation-origin=\"off\"><span class=\"informal\">A multicasted Observable uses a Subject under the hood to make multiple Observers see the same Observable execution.</span></p>\n\n<p translation-result=\"on\">在底層，這就是 <code><a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a></code> 運算子的工作方式： Observer 訂閱底層主體，主體訂閱源 Observable。下面的例子類似於前面使用 <code>observable.subscribe(subject)</code> 的例子：</p><p translation-origin=\"off\">Under the hood, this is how the <code><a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a></code> operator works: Observers subscribe to an underlying Subject, and the Subject subscribes to the source Observable. The following example is similar to the previous example which used <code>observable.subscribe(subject)</code>:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/from\" class=\"code-anchor\">from</a>, <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>, <a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst source = <a href=\"api/index/function/from\" class=\"code-anchor\">from</a>([1, 2, 3]);\nconst subject = new <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>();\nconst multicasted = source.pipe(<a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a>(subject));\n\n// These are, under the hood, `subject.subscribe({...})`:\nmulticasted.subscribe({\n  next: (v) => console.log(`observerA: ${v}`),\n});\nmulticasted.subscribe({\n  next: (v) => console.log(`observerB: ${v}`),\n});\n\n// This is, under the hood, `source.subscribe(subject)`:\nmulticasted.connect();\n</code-example>\n<p translation-result=\"on\"><code><a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a></code> 回傳一個看起來像普通 Observable 的 Observable，但在訂閱時會像 Subject 一樣工作。<code><a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a></code> 回傳一個 <code><a href=\"api/index/class/ConnectableObservable\" class=\"code-anchor\">ConnectableObservable</a></code>，它只是一個帶有 <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> 方法的 Observable。</p><p translation-origin=\"off\"><code><a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a></code> returns an Observable that looks like a normal Observable, but works like a Subject when it comes to subscribing. <code><a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a></code> returns a <code><a href=\"api/index/class/ConnectableObservable\" class=\"code-anchor\">ConnectableObservable</a></code>, which is simply an Observable with the <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> method.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> 方法對於確定共享的 Observable 何時開始執行非常重要。因為 <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> 在後台執行 <code>source.subscribe(subject)</code>，所以 <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> 回傳一個訂閱，你可以退訂以取消共享的 Observable 執行過程。</p><p translation-origin=\"off\">The <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> method is important to determine exactly when the shared Observable execution will start. Because <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> does <code>source.subscribe(subject)</code> under the hood, <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> returns a Subscription, which you can unsubscribe from in order to cancel the shared Observable execution.</p>\n\n<h3 id=\"reference-counting\" translation-result=\"on\">引用計數<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#reference-counting\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"reference-counting\">Reference counting<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#reference-counting\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">手動呼叫 <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> 並處理訂閱通常很麻煩。通常，我們希望在第一個 Observer 抵達時<em>自動</em>連線，並在最後一個 Observer 退訂時自動取消共享執行。</p><p translation-origin=\"off\">Calling <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> manually and handling the Subscription is often cumbersome. Usually, we want to <em>automatically</em> connect when the first Observer arrives, and automatically cancel the shared execution when the last Observer unsubscribes.</p>\n\n<p translation-result=\"on\">請考慮以下範例，其中發生了此清單中列出的訂閱：</p><p translation-origin=\"off\">Consider the following example where subscriptions occur as outlined by this list:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">第一個 Observer 訂閱了多播的 Observable</p><p translation-origin=\"off\">First Observer subscribes to the multicasted Observable</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>多播的 Observable 已連線</strong></p><p translation-origin=\"off\"><strong>The multicasted Observable is connected</strong></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>next</code> 值 <code>0</code> 被傳遞給第一個 Observer</p><p translation-origin=\"off\">The <code>next</code> value <code>0</code> is delivered to the first Observer</p>\n\n</li>\n<li>\n<p translation-result=\"on\">第二個 Observer 訂閱了多播的 Observable</p><p translation-origin=\"off\">Second Observer subscribes to the multicasted Observable</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>next</code> 的值 <code>1</code> 被傳遞給第一個 Observer</p><p translation-origin=\"off\">The <code>next</code> value <code>1</code> is delivered to the first Observer</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>next</code> 的值 <code>1</code> 被傳遞給第二個 Observer</p><p translation-origin=\"off\">The <code>next</code> value <code>1</code> is delivered to the second Observer</p>\n\n</li>\n<li>\n<p translation-result=\"on\">第一個 Observer 退訂多播的 Observable</p><p translation-origin=\"off\">First Observer unsubscribes from the multicasted Observable</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><code>next</code> 值 <code>2</code> 被傳遞給第二個 Observer</p><p translation-origin=\"off\">The <code>next</code> value <code>2</code> is delivered to the second Observer</p>\n\n</li>\n<li>\n<p translation-result=\"on\">第二個 Observer 退訂多播的 Observable</p><p translation-origin=\"off\">Second Observer unsubscribes from the multicasted Observable</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><strong>與多播的 Observable 的連線被退訂</strong></p><p translation-origin=\"off\"><strong>The connection to the multicasted Observable is unsubscribed</strong></p>\n\n</li>\n</ol>\n<p translation-result=\"on\">為了透過顯式呼叫 <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> 來實現這一點，我們編寫了以下程式碼：</p><p translation-origin=\"off\">To achieve that with explicit calls to <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code>, we write the following code:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>, <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>, <a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst source = <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>(500);\nconst subject = new <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>();\nconst multicasted = source.pipe(<a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a>(subject));\nlet subscription1, subscription2, subscriptionConnect;\n\nsubscription1 = multicasted.subscribe({\n  next: (v) => console.log(`observerA: ${v}`),\n});\n// We should call `<a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()` here, because the <a href=\"api/index/function/first\" class=\"code-anchor\">first</a>\n// subscriber to `multicasted` is interested in consuming values\nsubscriptionConnect = multicasted.connect();\n\nsetTimeout(() => {\n  subscription2 = multicasted.subscribe({\n    next: (v) => console.log(`observerB: ${v}`),\n  });\n}, 600);\n\nsetTimeout(() => {\n  subscription1.unsubscribe();\n}, 1200);\n\n// We should unsubscribe the shared <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> execution here,\n// because `multicasted` would have no more subscribers after this\nsetTimeout(() => {\n  subscription2.unsubscribe();\n  subscriptionConnect.unsubscribe(); // for the shared <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> execution\n}, 2000);\n</code-example>\n<p translation-result=\"on\">如果我們希望避免顯式呼叫 <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code>，可以使用 ConnectableObservable 的 <code>refCount()</code> 方法（引用計數），它回傳一個 Observable 來跟蹤它有多少訂閱者。當訂閱者數量從 <code>0</code> 增加到 <code>1</code> 時，它會為我們呼叫 <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code>，從而開始共享執行。只有當訂閱者數量從 <code>1</code> 減少到 <code>0</code> 時，才會完全退訂，並停止進一步執行。</p><p translation-origin=\"off\">If we wish to avoid explicit calls to <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code>, we can use ConnectableObservable's <code>refCount()</code> method (reference counting), which returns an Observable that keeps track of how many subscribers it has. When the number of subscribers increases from <code>0</code> to <code>1</code>, it will call <code><a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()</code> for us, which starts the shared execution. Only when the number of subscribers decreases from <code>1</code> to <code>0</code> will it be fully unsubscribed, stopping further execution.</p>\n\n<p translation-result=\"on\"><span class=\"informal\"><code>refCount</code> 能使多播的 Observable 在第一個訂閱者抵達時自動開始執行，並在最後一個訂閱者離開時停止執行。</span></p><p translation-origin=\"off\"><span class=\"informal\"><code>refCount</code> makes the multicasted Observable automatically start executing when the first subscriber arrives, and stop executing when the last subscriber leaves.</span></p>\n\n<p translation-result=\"on\">下面是一個例子：</p><p translation-origin=\"off\">Below is an example:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>, <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>, <a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a>, refCount } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst source = <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>(500);\nconst subject = new <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>();\nconst refCounted = source.pipe(<a href=\"api/index/function/multicast\" class=\"code-anchor\">multicast</a>(subject), refCount());\nlet subscription1, subscription2;\n\n// This calls `<a href=\"api/index/function/connect\" class=\"code-anchor\">connect</a>()`, because\n// it is the <a href=\"api/index/function/first\" class=\"code-anchor\">first</a> subscriber to `refCounted`\nconsole.log('observerA subscribed');\nsubscription1 = refCounted.subscribe({\n  next: (v) => console.log(`observerA: ${v}`),\n});\n\nsetTimeout(() => {\n  console.log('observerB subscribed');\n  subscription2 = refCounted.subscribe({\n    next: (v) => console.log(`observerB: ${v}`),\n  });\n}, 600);\n\nsetTimeout(() => {\n  console.log('observerA unsubscribed');\n  subscription1.unsubscribe();\n}, 1200);\n\n// This is when the shared <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a> execution will stop, because\n// `refCounted` would have no more subscribers after this\nsetTimeout(() => {\n  console.log('observerB unsubscribed');\n  subscription2.unsubscribe();\n}, 2000);\n\n// Logs\n// observerA subscribed\n// observerA: 0\n// observerB subscribed\n// observerA: 1\n// observerB: 1\n// observerA unsubscribed\n// observerB: 2\n// observerB unsubscribed\n</code-example>\n<p translation-result=\"on\"><code>refCount()</code> 方法只存在於 ConnectableObservable 上，它回傳一個 <code><a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code>，而不是另一個 ConnectableObservable。</p><p translation-origin=\"off\">The <code>refCount()</code> method only exists on ConnectableObservable, and it returns an <code><a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a></code>, not another ConnectableObservable.</p>\n\n<h2 id=\"behaviorsubject\" translation-result=\"on\">行為主體<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#behaviorsubject\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"behaviorsubject\">BehaviorSubject<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#behaviorsubject\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Subjects 的變體之一是 <code><a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a></code>，它具有『當前值』的概念。它儲存傳送給其消費者的最新值，並且每當有新的 Observer 訂閱時，它將立即從 <code><a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a></code> 接收到『當前值』。</p><p translation-origin=\"off\">One of the variants of Subjects is the <code><a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a></code>, which has a notion of \"the current value\". It stores the latest value emitted to its consumers, and whenever a new Observer subscribes, it will immediately receive the \"current value\" from the <code><a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a></code>.</p>\n\n<p translation-result=\"on\"><span class=\"informal\">BehaviorSubjects 對於表示『隨時間變化的值』很有用。例如，生日事件流是一個主體，但一個人的年齡流是一個行為主體。</span></p><p translation-origin=\"off\"><span class=\"informal\">BehaviorSubjects are useful for representing \"values over time\". For instance, an event stream of birthdays is a Subject, but the stream of a person's age would be a BehaviorSubject.</span></p>\n\n<p translation-result=\"on\">在下面的範例中，BehaviorSubject 使用第一個 Observer 在訂閱時收到的值 <code>0</code> 進行初始化。第二個 Observer 接收到值 <code>2</code>，即使它是在傳送值 <code>2</code> 之後訂閱的。</p><p translation-origin=\"off\">In the following example, the BehaviorSubject is initialized with the value <code>0</code> which the first Observer receives when it subscribes. The second Observer receives the value <code>2</code> even though it subscribed after the value <code>2</code> was sent.</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\nconst subject = new <a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a>(0); // 0 is the initial value\n\nsubject.subscribe({\n  next: (v) => console.log(`observerA: ${v}`),\n});\n\nsubject.next(1);\nsubject.next(2);\n\nsubject.subscribe({\n  next: (v) => console.log(`observerB: ${v}`),\n});\n\nsubject.next(3);\n\n// Logs\n// observerA: 0\n// observerA: 1\n// observerA: 2\n// observerB: 2\n// observerA: 3\n// observerB: 3\n</code-example>\n<h2 id=\"replaysubject\" translation-result=\"on\">重播主體<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#replaysubject\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"replaysubject\">ReplaySubject<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#replaysubject\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code><a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a></code> 與 <code><a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a></code> 類似，它可以將舊值傳送給新訂閱者，但它也可以<em>記錄</em> Observable 執行結果的一部分。</p><p translation-origin=\"off\">A <code><a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a></code> is similar to a <code><a href=\"api/index/class/BehaviorSubject\" class=\"code-anchor\">BehaviorSubject</a></code> in that it can send old values to new subscribers, but it can also <em>record</em> a part of the Observable execution.</p>\n\n<p translation-result=\"on\"><span class=\"informal\"><code><a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a></code> 會記錄來自 Observable 執行的多個值，並將它們重播給新訂閱者。</span></p><p translation-origin=\"off\"><span class=\"informal\">A <code><a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a></code> records multiple values from the Observable execution and replays them to new subscribers.</span></p>\n\n<p translation-result=\"on\">建立 <code><a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a></code> 時，你可以指定要重播的值的數量：</p><p translation-origin=\"off\">When creating a <code><a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a></code>, you can specify how many values to replay:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\nconst subject = new <a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a>(3); // <a href=\"api/index/function/buffer\" class=\"code-anchor\">buffer</a> 3 values for new subscribers\n\nsubject.subscribe({\n  next: (v) => console.log(`observerA: ${v}`),\n});\n\nsubject.next(1);\nsubject.next(2);\nsubject.next(3);\nsubject.next(4);\n\nsubject.subscribe({\n  next: (v) => console.log(`observerB: ${v}`),\n});\n\nsubject.next(5);\n\n// Logs:\n// observerA: 1\n// observerA: 2\n// observerA: 3\n// observerA: 4\n// observerB: 2\n// observerB: 3\n// observerB: 4\n// observerA: 5\n// observerB: 5\n</code-example>\n<p translation-result=\"on\">除了緩衝區大小之外，你還可以指定一個以毫秒為單位的<em>視窗時間</em>，以確定記錄的值可以存在多長時間。在以下範例中，我們使用 <code>100</code> 個元素的大型緩衝區，但視窗時間引數僅為 <code>500</code> 毫秒。</p><p translation-origin=\"off\">You can also specify a <em>window time</em> in milliseconds, besides of the buffer size, to determine how old the recorded values can be. In the following example we use a large buffer size of <code>100</code>, but a window time parameter of just <code>500</code> milliseconds.</p>\n\n<!-- skip-example -->\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\nconst subject = new <a href=\"api/index/class/ReplaySubject\" class=\"code-anchor\">ReplaySubject</a>(100, 500 /* <a href=\"api/index/function/windowTime\" class=\"code-anchor\">windowTime</a> */);\n\nsubject.subscribe({\n  next: (v) => console.log(`observerA: ${v}`),\n});\n\nlet i = 1;\nsetInterval(() => subject.next(i++), 200);\n\nsetTimeout(() => {\n  subject.subscribe({\n    next: (v) => console.log(`observerB: ${v}`),\n  });\n}, 1000);\n\n// Logs\n// observerA: 1\n// observerA: 2\n// observerA: 3\n// observerA: 4\n// observerA: 5\n// observerB: 3\n// observerB: 4\n// observerB: 5\n// observerA: 6\n// observerB: 6\n// ...\n</code-example>\n<h2 id=\"asyncsubject\" translation-result=\"on\">非同步主體<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#asyncsubject\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"asyncsubject\">AsyncSubject<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#asyncsubject\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">AsyncSubject 是一種變體，其中僅將 Observable 執行的最後一個值傳送給其 Observer，並且僅在執行完成時傳送。</p><p translation-origin=\"off\">The AsyncSubject is a variant where only the last value of the Observable execution is sent to its observers, and only when the execution completes.</p>\n\n<code-example language=\"js\">\nimport { <a href=\"api/index/class/AsyncSubject\" class=\"code-anchor\">AsyncSubject</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\nconst subject = new <a href=\"api/index/class/AsyncSubject\" class=\"code-anchor\">AsyncSubject</a>();\n\nsubject.subscribe({\n  next: (v) => console.log(`observerA: ${v}`),\n});\n\nsubject.next(1);\nsubject.next(2);\nsubject.next(3);\nsubject.next(4);\n\nsubject.subscribe({\n  next: (v) => console.log(`observerB: ${v}`),\n});\n\nsubject.next(5);\nsubject.complete();\n\n// Logs:\n// observerA: 5\n// observerB: 5\n</code-example>\n<p translation-result=\"on\">AsyncSubject 類似於 <a href=\"/api/operators/last\"><code>last()</code></a> 運算子，因為它會等待 <code>complete</code> 通知以傳遞單個值。</p><p translation-origin=\"off\">The AsyncSubject is similar to the <a href=\"/api/operators/last\"><code>last()</code></a> operator, in that it waits for the <code>complete</code> notification in order to deliver a single value.</p>\n\n<h2 id=\"void-subject\" translation-result=\"on\">void 主體<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#void-subject\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"void-subject\">Void subject<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/subject#void-subject\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">有時，發出值這件事本身比所發出的值更重要。</p><p translation-origin=\"off\">Sometimes the emitted value doesn't matter as much as the fact that a value was emitted.</p>\n\n<p translation-result=\"on\">例如，下面的代碼表示已經過了一秒鐘。</p><p translation-origin=\"off\">For instance, the code below signals that one second has passed.</p>\n\n<code-example language=\"ts\">\nconst subject = new <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;string>();\nsetTimeout(() => subject.next('dummy'), 1000);\n</code-example>\n<p translation-result=\"on\">以這種方式傳遞一個虛擬值很笨拙，並且可能會使用戶感到困惑。</p><p translation-origin=\"off\">Passing a dummy value this way is clumsy and can confuse users.</p>\n\n<p translation-result=\"on\">透過宣告一個 <em>void 主體</em>，你可以表明該值是無所謂的。只有事件本身才重要。</p><p translation-origin=\"off\">By declaring a <em>void subject</em>, you signal that the value is irrelevant. Only the event itself matters.</p>\n\n<code-example language=\"ts\">\nconst subject = new <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;void>();\nsetTimeout(() => subject.next(), 1000);\n</code-example>\n<p translation-result=\"on\">帶有上下文的完整範例如下所示：</p><p translation-origin=\"off\">A complete example with context is shown below:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst subject = new <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>(); // Shorthand for <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;void>\n\nsubject.subscribe({\n  next: () => console.log('One second has passed'),\n});\n\nsetTimeout(() => subject.next(), 1000);\n</code-example>\n<p translation-result=\"on\"><span class=\"informal\">在版本 7 之前，Subject 值的預設類型是 <code>any</code>。<code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;any></code> 停用發出值的型別檢查，而 <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;void></code> 可以防止意外訪問所發出的值。如果你想要老式行為，請將 <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a></code> 替換為 <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;any></code>。</span></p><p translation-origin=\"off\"><span class=\"informal\">Before version 7, the default type of Subject values was <code>any</code>. <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;any></code> disables type checking of the emitted values, whereas <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;void></code> prevents accidental access to the emitted value. If you want the old behavior, then replace <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a></code> with <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>&#x3C;any></code>.</span></p>\n\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /api/operators/last\n - api/index/class/AsyncSubject\n - api/index/class/BehaviorSubject\n - api/index/class/ConnectableObservable\n - api/index/class/Observable\n - api/index/class/ReplaySubject\n - api/index/class/Subject\n - api/index/const/observable\n - api/index/function/buffer\n - api/index/function/connect\n - api/index/function/first\n - api/index/function/from\n - api/index/function/interval\n - api/index/function/multicast\n - api/index/function/windowTime\n - guide/subject#asyncsubject\n - guide/subject#behaviorsubject\n - guide/subject#multicasted-observables\n - guide/subject#reference-counting\n - guide/subject#replaysubject\n - guide/subject#subject\n - guide/subject#void-subject\n-->"
}