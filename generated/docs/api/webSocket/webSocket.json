{
  "id": "api/webSocket/webSocket",
  "title": "webSocket",
  "contents": "\n\n<article>\n  <div class=\"page-actions\">\n    <a href=\"https://github.com/reactivex/rxjs/edit/master/src/internal/observable/dom/webSocket.ts?message=docs(webSocket)%3A%20describe%20your%20change...#L2-L199\" aria-label=\"編輯建議\" title=\"編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n    <a href=\"https://github.com/reactivex/rxjs/tree/7.5.2/src/internal/observable/dom/webSocket.ts#L2-L199\" aria-label=\"檢視原始碼\" title=\"檢視原始碼\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">code</i></a>\n  </div>\n    <div class=\"breadcrumb\">\n      <script type=\"application/ld+json\">\n        {\n          \"@context\": \"http://schema.org\",\n          \"@type\": \"BreadcrumbList\",\n          \"itemListElement\": [\n          { \"@type\": \"ListItem\", \"position\": 1, \"item\": { \"@id\": \"https://angular.io//api\", \"name\": \"API\" } },\n          { \"@type\": \"ListItem\", \"position\": 2, \"item\": { \"@id\": \"https://angular.io/api/webSocket\", \"name\": \"rxjs/webSocket\" } },\n          { \"@type\": \"ListItem\", \"position\": 3, \"item\": { \"@id\": \"https://angular.io/api/webSocket/webSocket\", \"name\": \"webSocket\" } }\n          ]\n        }\n      </script>\n      <a href=\"/api\">API</a> / <a href=\"api/webSocket\">rxjs/webSocket</a>\n    </div>\n  <header class=\"api-header\">\n    <h1 id=\"websocket\">webSocket<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/webSocket/webSocket#websocket\"><i class=\"material-icons\">link</i></a></h1>\n    <label class=\"api-type-label function\">function</label>\n    \n    \n    <label class=\"api-status-label stable\">穩定</label>\n    \n    \n  </header>\n  <aio-toc class=\"embedded\"></aio-toc>\n\n  <div class=\"api-body\">\n    \n  \n\n  <p class=\"short-description\"></p><p translation-result=\"on\">圍繞瀏覽器提供的、與 w3c 相容的 WebSocket 物件進行包裝。</p><p translation-origin=\"off\">Wrapper around the w3c-compatible WebSocket object provided by the browser.</p>\n\n<p></p>\n  \n\n  \n\n  \n\n  <code-example language=\"ts\" hidecopy=\"true\" class=\"no-box api-heading\"> webSocket&#x3C;T>(urlConfigOrSource: string | <a href=\"api/webSocket/WebSocketSubjectConfig\" class=\"code-anchor\">WebSocketSubjectConfig</a>&#x3C;T>): <a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a>&#x3C;T></code-example>\n\n\n\n\n  <h4 class=\"no-anchor\" id=\"parameters\">引數</h4>\n  <table class=\"is-full-width list-table parameters-table function-overload-parameters\">\n  <tbody>\n  \n    <tr class=\"function-overload-parameter\">\n      <td class=\"param-name\"><a id=\"\"></a>urlConfigOrSource</td>\n      \n      <td class=\"param-description\">\n      <p translation-result=\"on\">WebSocket 端點作為 url 或具有設定和其它 Observer 的物件。</p><p translation-origin=\"off\">        The WebSocket endpoint as an url or an object with\nconfiguration and additional Observers.</p>\n\n\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n  \n  <h4 class=\"no-anchor\" id=\"回傳值\">回傳值</h4>\n  <p translation-result=\"on\">允許透過 WebSocket 連線傳送和接收訊息的主體。</p><p translation-origin=\"off\"><code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject&#x3C;T></a></code>: Subject which allows to both send and receive messages via WebSocket connection.</p>\n\n\n  \n\n\n\n\n\n\n\n  \n\n<section class=\"description\">\n  <h2 id=\"description\">說明<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/webSocket/webSocket#description\"><i class=\"material-icons\">link</i></a></h2>\n  <p translation-result=\"on\"><span class=\"informal\"><a href=\"api/index/class/Subject\"><code>Subject</code></a> 透過 WebSocket 與伺服器通訊</span></p><p translation-origin=\"off\"><span class=\"informal\"><a href=\"api/index/class/Subject\"><code>Subject</code></a> that communicates with a server via WebSocket</span></p>\n\n<p translation-result=\"on\"><code>webSocket</code> 是一個生成 <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> 的工廠函式，可用於與任意端點建立 WebSocket 連線。<code>webSocket</code> 接受帶有 WebSocket 端點 url 的字串或 <a href=\"api/webSocket/WebSocketSubjectConfig\"><code>WebSocketSubjectConfig</code></a> 物件作為引數，用於提供額外的設定，以及用於跟蹤 WebSocket 連線的生命週期的 Observer。</p><p translation-origin=\"off\"><code>webSocket</code> is a factory function that produces a <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code>,\nwhich can be used to make WebSocket connection with an arbitrary endpoint.\n<code>webSocket</code> accepts as an argument either a string with url of WebSocket endpoint, or an\n<a href=\"api/webSocket/WebSocketSubjectConfig\"><code>WebSocketSubjectConfig</code></a> object for providing additional configuration, as\nwell as Observers for tracking lifecycle of WebSocket connection.</p>\n\n<p translation-result=\"on\">當 <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> 被訂閱時，它會嘗試建立一個 Socket 連線，除非已經建立了一個。這意味著許多訂閱者將始終在同一個 Socket 上偵聽，從而節省資源。但是，如果兩個實例由 <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> 組成，即使這兩個實例提供了相同的 url，它們也會嘗試建立單獨的連線。當 <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> 的消費者退訂時，只有在沒有更多訂閱者仍在監聽的情況下，才會關閉 Socket 連線。如果一段時間後消費者再次開始訂閱，則重新建立連線。</p><p translation-origin=\"off\">When <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> is subscribed, it attempts to make a socket connection,\nunless there is one made already. This means that many subscribers will always listen\non the same socket, thus saving resources. If however, two instances are made of <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code>,\neven if these two were provided with the same url, they will attempt to make separate\nconnections. When consumer of a <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> unsubscribes, socket connection is closed,\nonly if there are no more subscribers still listening. If after some time a consumer starts\nsubscribing again, connection is reestablished.</p>\n\n<p translation-result=\"on\">一旦建立連線，每當有新訊息來自伺服器時，<code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> 都會將該訊息作為流中的值發出。預設情況下，來自 Socket 的訊息會通過 <code>JSON.parse</code> 解析。如果你想自定義如何處理反序列化（如果有的話），你可以在 <a href=\"api/webSocket/WebSocketSubject\"><code>WebSocketSubject</code></a> 中提供自定義 <code>resultSelector</code> 函式。當連線關閉時，流將完成，前提是它沒有任何錯誤發生。如果在任何時候（啟動、維護或關閉連線）出現錯誤，無論 WebSocket API 丟擲什麼，流都會出錯。</p><p translation-origin=\"off\">Once connection is made, whenever a new message comes from the server, <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> will emit that\nmessage as a value in the stream. By default, a message from the socket is parsed via <code>JSON.parse</code>. If you\nwant to customize how deserialization is handled (if at all), you can provide custom <code>resultSelector</code>\nfunction in <a href=\"api/webSocket/WebSocketSubject\"><code>WebSocketSubject</code></a>. When connection closes, stream will complete, provided it happened without\nany errors. If at any point (starting, maintaining or closing a connection) there is an error,\nstream will also error with whatever WebSocket API has thrown.</p>\n\n<p translation-result=\"on\">由於是 <a href=\"api/index/class/Subject\"><code>Subject</code></a>，<code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> 允許從伺服器接收和傳送訊息。為了與連線的端點通訊，請使用 <code>next</code>、<code>error</code> 和 <code>complete</code> 方法。<code>next</code> 會向伺服器傳送一個值，請記住，該值不會事先序列化。因此，在使用某個結果呼叫 <code>next</code> 之前，必須手動對該值呼叫 <code>JSON.stringify</code>。另請注意，如果在下一個值抵達的時刻沒有 Socket 連線（例如沒有人訂閱），則這些值將被緩衝，並在最終建立連線時傳送。<code>complete</code> 方法關閉 Socket 連線。<code>error</code> 也是如此，並透過狀態程式碼和字串通知伺服器出現問題，並提供詳細訊息。由於 WebSocket API 中需要狀態碼，因此 <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> 不允許像常規 <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a></code> 一樣，將任意值傳給 <code>error</code> 方法。需要使用帶狀態程式碼數字的 <code>code</code> 屬性和帶有描述錯誤詳情的可選字串屬性 <code>reason</code> 的物件來呼叫它。</p><p translation-origin=\"off\">By virtue of being a <a href=\"api/index/class/Subject\"><code>Subject</code></a>, <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> allows for receiving and sending messages from the server. In order\nto communicate with a connected endpoint, use <code>next</code>, <code>error</code> and <code>complete</code> methods. <code>next</code> sends a value to the server, so bear in mind\nthat this value will not be serialized beforehand. Because of This, <code>JSON.stringify</code> will have to be called on a value by hand,\nbefore calling <code>next</code> with a result. Note also that if at the moment of nexting value\nthere is no socket connection (for example no one is subscribing), those values will be buffered, and sent when connection\nis finally established. <code>complete</code> method closes socket connection. <code>error</code> does the same,\nas well as notifying the server that something went wrong via status code and string with details of what happened.\nSince status code is required in WebSocket API, <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> does not allow, like regular <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a></code>,\narbitrary values being passed to the <code>error</code> method. It needs to be called with an object that has <code>code</code>\nproperty with status code number and optional <code>reason</code> property with string describing details\nof an error.</p>\n\n<p translation-result=\"on\">呼叫 <code>next</code> 不會影響 <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> 的訂閱者 - 他們沒有任何訊息表明某些內容已傳送到伺服器（當然，除非伺服器以某種方式回應訊息）。另一方面，由於呼叫 <code>complete</code> 會觸發關閉 Socket 連線的嘗試。如果該連線在沒有任何錯誤的情況下關閉，則此流將完成，從而通知所有訂閱者。而且由於呼叫 <code>error</code> 也會關閉 Socket 連線（只是伺服器的狀態碼不同），如果關閉本身沒有錯誤，則訂閱的 Observable 將不會出錯（正如人們所期望的那樣），但會正常完成。在這兩種情況下（呼叫 <code>complete</code> 或 <code>error</code>），如果關閉 Socket 連線的過程導致一些錯誤，<em>則</em>流將出錯。</p><p translation-origin=\"off\">Calling <code>next</code> does not affect subscribers of <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> - they have no\ninformation that something was sent to the server (unless of course the server\nresponds somehow to a message). On the other hand, since calling <code>complete</code> triggers\nan attempt to close socket connection. If that connection is closed without any errors, stream will\ncomplete, thus notifying all subscribers. And since calling <code>error</code> closes\nsocket connection as well, just with a different status code for the server, if closing itself proceeds\nwithout errors, subscribed Observable will not error, as one might expect, but complete as usual. In both cases\n(calling <code>complete</code> or <code>error</code>), if process of closing socket connection results in some errors, <em>then</em> stream\nwill error.</p>\n\n<p translation-result=\"on\"><strong>multiplex（多路複用）</strong></p><p translation-origin=\"off\"><strong>Multiplexing</strong></p>\n\n<p translation-result=\"on\"><code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> 有一個額外的運算子，在其它 Subjects 中沒有。它被稱為 <code>multiplex</code>，它用於模擬開啟多個 Socket 連線，而實際上只真正維護一個。例如，一個應用程式既有聊天面板，也有關於體育新聞的實時通知。由於這是兩個不同的功能，因此為每個功能設定兩個單獨的連線是有意義的。也許甚至可以有兩個具有 WebSocket 端點的單獨服務，在單獨的機器上執行，只有 GUI 將它們組合在一起。每個功能都有一個 Socket 連線可能會變得過於昂貴。將單個 WebSocket 端點用作其它服務（在本例中為聊天和體育新聞服務）的閘道器是一種常見模式。即使用戶端應用程式中只有一個連線，也希望能夠像處理兩個單獨的 Socket 一樣操作流。這省去了在閘道器中手動註冊和登出給定服務的工作，並過濾掉某些感興趣的訊息。這正是 <code>multiplex</code> 方法的用途。</p><p translation-origin=\"off\"><code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> has an additional operator, not found in other Subjects. It is called <code>multiplex</code> and it is\nused to simulate opening several socket connections, while in reality maintaining only one.\nFor example, an application has both chat panel and real-time notifications about sport news. Since these are two distinct functions,\nit would make sense to have two separate connections for each. Perhaps there could even be two separate services with WebSocket\nendpoints, running on separate machines with only GUI combining them together. Having a socket connection\nfor each functionality could become too resource expensive. It is a common pattern to have single\nWebSocket endpoint that acts as a gateway for the other services (in this case chat and sport news services).\nEven though there is a single connection in a client app, having the ability to manipulate streams as if it\nwere two separate sockets is desirable. This eliminates manually registering and unregistering in a gateway for\ngiven service and filter out messages of interest. This is exactly what <code>multiplex</code> method is for.</p>\n\n<p translation-result=\"on\">方法接受三個引數。前兩個分別是回傳訂閱和退訂訊息的函式。每當結果 Observable 的消費者訂閱和退訂時，這些訊息都會傳送到伺服器。伺服器可以使用它們來驗證某種訊息是應該開始還是停止轉發給用戶端。在上面的範例應用程式中，在獲得具有適當識別符號的訂閱訊息後，閘道器伺服器決定它要連線到真實的體育新聞服務並開始從中轉發訊息。請注意，這兩條訊息都將作為函式回傳的內容傳送，預設情況下，它們會使用 JSON.stringify 進行序列化，就像透過 <code>next</code> 推送的訊息一樣。另請記住，這些訊息會在<em>每次</em>訂閱和退訂時傳送。這是潛在的危險，因為 Observable 的一個消費者可能會退訂，並且伺服器可能會停止傳送訊息，因為它收到了退訂訊息。這需要在服務器上處理，或者在從『multiplex』回傳的 Observable 上使用 <a href=\"api/index/function/publish\"><code>publish</code></a>。</p><p translation-origin=\"off\">Method accepts three parameters. First two are functions returning subscription and unsubscription messages\nrespectively. These are messages that will be sent to the server, whenever consumer of resulting Observable\nsubscribes and unsubscribes. Server can use them to verify that some kind of messages should start or stop\nbeing forwarded to the client. In case of the above example application, after getting subscription message with proper identifier,\ngateway server can decide that it should connect to real sport news service and start forwarding messages from it.\nNote that both messages will be sent as returned by the functions, they are by default serialized using JSON.stringify, just\nas messages pushed via <code>next</code>. Also bear in mind that these messages will be sent on <em>every</em> subscription and\nunsubscription. This is potentially dangerous, because one consumer of an Observable may unsubscribe and the server\nmight stop sending messages, since it got unsubscription message. This needs to be handled\non the server or using <a href=\"api/index/function/publish\"><code>publish</code></a> on a Observable returned from 'multiplex'.</p>\n\n<p translation-result=\"on\"><code>multiplex</code> 的最後一個引數是一個 <code>messageFilter</code> 函式，它應該回傳一個布林值。它用於過濾伺服器傳送的訊息，只發送給那些屬於模擬 WebSocket 流的訊息。例如，伺服器可能會在訊息物件上用某種字串識別符號標記這些訊息，如果 Socket 發出的物件上有這樣的識別符號，則 <code>messageFilter</code> 將回傳 <code>true</code>。在 <code>messageFilter</code> 中回傳 <code>false</code> 的訊息將被簡單地跳過，並且不會沿著流向下傳遞。</p><p translation-origin=\"off\">Last argument to <code>multiplex</code> is a <code>messageFilter</code> function which should return a boolean. It is used to filter out messages\nsent by the server to only those that belong to simulated WebSocket stream. For example, server might mark these\nmessages with some kind of string identifier on a message object and <code>messageFilter</code> would return <code>true</code>\nif there is such identifier on an object emitted by the socket. Messages which returns <code>false</code> in <code>messageFilter</code> are simply skipped,\nand are not passed down the stream.</p>\n\n<p translation-result=\"on\"><code>multiplex</code> 的回傳值是一個 Observable，其中包含從模擬 Socket 連線傳入的訊息。請注意，這不是 <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code>，因此再次呼叫 <code>next</code> 或 <code>multiplex</code> 將失敗。要將值推送到伺服器，請使用根 <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code>。</p><p translation-origin=\"off\">Return value of <code>multiplex</code> is an Observable with messages incoming from emulated socket connection. Note that this\nis not a <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code>, so calling <code>next</code> or <code>multiplex</code> again will fail. For pushing values to the\nserver, use root <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code>.</p>\n\n<h2 id=\"examples\" translation-result=\"on\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/webSocket/webSocket#examples\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"examples\">Examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/webSocket/webSocket#examples\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">監聽來自伺服器的訊息</p><p translation-origin=\"off\">Listening for messages from the server</p>\n\n<code-example language=\"ts\">\nimport { webSocket } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs/webSocket';\n\nconst subject = webSocket('ws://localhost:8081');\n\nsubject.subscribe({\n  next: msg => console.log('message received: ' + msg), // Called whenever there is a message <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> the server.\n  error: err => console.log(err), // Called if at any point WebSocket API signals some kind <a href=\"api/index/function/of\" class=\"code-anchor\">of</a> error.\n  complete: () => console.log('complete') // Called when connection is closed (for whatever reason).\n });\n</code-example>\n<p translation-result=\"on\">向伺服器推送訊息</p><p translation-origin=\"off\">Pushing messages to the server</p>\n\n<code-example language=\"ts\">\nimport { webSocket } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs/webSocket';\n\nconst subject = webSocket('ws://localhost:8081');\n\nsubject.subscribe();\n// Note that at least one consumer has to subscribe to the created subject - otherwise \"nexted\" values will be just buffered and not sent,\n// since no connection was established!\n\nsubject.next({ message: 'some message' });\n// This will send a message to the server once a connection is made. Remember value is serialized with JSON.stringify by default!\n\nsubject.complete(); // Closes the connection.\n\nsubject.error({ code: 4000, reason: 'I think our app just broke!' });\n// Also closes the connection, but let's the server know that this closing is caused by some error.\n</code-example>\n<p translation-result=\"on\">多路複用 WebSocket</p><p translation-origin=\"off\">Multiplexing WebSocket</p>\n\n<code-example language=\"ts\">\nimport { webSocket } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs/webSocket';\n\nconst subject = webSocket('ws://localhost:8081');\n\nconst observableA = subject.multiplex(\n  () => ({ subscribe: 'A' }), // When server gets this message, it will start sending messages for 'A'...\n  () => ({ unsubscribe: 'A' }), // ...and when gets this one, it will stop.\n  message => message.type === 'A' // If the function returns `true` message is passed down the stream. Skipped if the function returns false.\n);\n\nconst observableB = subject.multiplex( // And the same goes for 'B'.\n  () => ({ subscribe: 'B' }),\n  () => ({ unsubscribe: 'B' }),\n  message => message.type === 'B'\n);\n\nconst subA = observableA.subscribe(messageForA => console.log(messageForA));\n// At this moment WebSocket connection is established. Server gets '{\"subscribe\": \"A\"}' message and starts sending messages for 'A',\n// which we log here.\n\nconst subB = observableB.subscribe(messageForB => console.log(messageForB));\n// Since we already have a connection, we just send '{\"subscribe\": \"B\"}' message to the server. It starts sending messages for 'B',\n// which we log here.\n\nsubB.unsubscribe();\n// Message '{\"unsubscribe\": \"B\"}' is sent to the server, which stops sending 'B' messages.\n\nsubA.unsubscribe();\n// Message '{\"unsubscribe\": \"A\"}' makes the server stop sending messages for 'A'. Since there is no more subscribers to root <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>,\n// socket connection closes.\n</code-example>\n\n</section>\n\n\n\n\n  \n\n  \n\n\n  </div>\n</article>\n\n<!-- links to this doc:\n - api/webSocket\n - api/webSocket/WebSocketSubjectConfig\n-->\n<!-- links from this doc:\n - /api\n - api/index/class/Subject\n - api/index/function/from\n - api/index/function/of\n - api/index/function/publish\n - api/webSocket\n - api/webSocket/WebSocketSubject\n - api/webSocket/WebSocketSubjectConfig\n - api/webSocket/webSocket#description\n - api/webSocket/webSocket#examples\n - api/webSocket/webSocket#websocket\n - https://github.com/reactivex/rxjs/edit/master/src/internal/observable/dom/webSocket.ts?message=docs(webSocket)%3A%20describe%20your%20change...#L2-L199\n - https://github.com/reactivex/rxjs/tree/7.5.2/src/internal/observable/dom/webSocket.ts#L2-L199\n-->"
}