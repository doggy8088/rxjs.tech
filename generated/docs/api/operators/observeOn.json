{
  "id": "api/operators/observeOn",
  "title": "observeOn",
  "contents": "\n\n<article>\n  <div class=\"page-actions\">\n    <a href=\"https://github.com/reactivex/rxjs/edit/master/src/internal/operators/observeOn.ts?message=docs(operators)%3A%20describe%20your%20change...#L6-L91\" aria-label=\"編輯建議\" title=\"編輯建議\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n    <a href=\"https://github.com/reactivex/rxjs/tree/7.5.2/src/internal/operators/observeOn.ts#L6-L91\" aria-label=\"檢視原始碼\" title=\"檢視原始碼\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">code</i></a>\n  </div>\n    <div class=\"breadcrumb\">\n      <script type=\"application/ld+json\">\n        {\n          \"@context\": \"http://schema.org\",\n          \"@type\": \"BreadcrumbList\",\n          \"itemListElement\": [\n          { \"@type\": \"ListItem\", \"position\": 1, \"item\": { \"@id\": \"https://angular.io//api\", \"name\": \"API\" } },\n          { \"@type\": \"ListItem\", \"position\": 2, \"item\": { \"@id\": \"https://angular.io/api/operators\", \"name\": \"rxjs/operators\" } },\n          { \"@type\": \"ListItem\", \"position\": 3, \"item\": { \"@id\": \"https://angular.io/api/operators/observeOn\", \"name\": \"observeOn\" } }\n          ]\n        }\n      </script>\n      <a href=\"/api\">API</a> / <a href=\"api/operators\">rxjs/operators</a>\n    </div>\n  <header class=\"api-header\">\n    <h1 id=\"observeon\">observeOn<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/operators/observeOn#observeon\"><i class=\"material-icons\">link</i></a></h1>\n    <label class=\"api-type-label function\">function</label>\n    \n    \n    <label class=\"api-status-label stable\">穩定</label>\n    \n    <label class=\"api-status-label operator\">運算子</label>\n  </header>\n  <aio-toc class=\"embedded\"></aio-toc>\n\n  <div class=\"api-body\">\n    \n  \n\n  <p class=\"short-description\"></p><p translation-result=\"on\">使用指定的排程器從來源 Observable 重新傳送所有通知。</p><p translation-origin=\"off\">Re-emits all notifications from source Observable with specified scheduler.</p>\n\n<p></p>\n  \n\n  \n\n  \n\n  <code-example language=\"ts\" hidecopy=\"true\" class=\"no-box api-heading\"> <a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a>&#x3C;T>(scheduler: <a href=\"api/index/interface/SchedulerLike\" class=\"code-anchor\">SchedulerLike</a>, <a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a>: number = 0): <a href=\"api/index/interface/MonoTypeOperatorFunction\" class=\"code-anchor\">MonoTypeOperatorFunction</a>&#x3C;T></code-example>\n\n\n\n\n  <h4 class=\"no-anchor\" id=\"parameters\">引數</h4>\n  <table class=\"is-full-width list-table parameters-table function-overload-parameters\">\n  <tbody>\n  \n    <tr class=\"function-overload-parameter\">\n      <td class=\"param-name\"><a id=\"\"></a>scheduler</td>\n      \n      <td class=\"param-description\">\n      <p translation-result=\"on\">一個排程器，用於重新排程來自來源 Observable 的通知。</p><p translation-origin=\"off\">        Scheduler that will be used to reschedule notifications from source Observable.</p>\n\n\n      </td>\n    </tr>\n    <tr class=\"function-overload-parameter\">\n      <td class=\"param-name\"><a id=\"\"></a>delay</td>\n      \n      <td class=\"param-description\">\n      <p>        可選。預設值為 <code>0</code>。</p>\n<p translation-result=\"on\">一個毫秒數，用於指定重新排程每個通知的延遲時間。</p><p translation-origin=\"off\">        Number of milliseconds that states with what delay every notification should be rescheduled.</p>\n\n\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n  \n  <h4 class=\"no-anchor\" id=\"回傳值\">回傳值</h4>\n  <p translation-result=\"on\">一個回傳 Observable 的函式，它會發送與來源 Observable 相同的通知，但使用指定的排程器。</p><p translation-origin=\"off\"><code><a href=\"api/index/interface/MonoTypeOperatorFunction\" class=\"code-anchor\">MonoTypeOperatorFunction&#x3C;T></a></code>: A function that returns an Observable that emits the same\nnotifications as the source Observable, but with provided scheduler.</p>\n\n\n  \n\n\n\n\n\n\n\n  \n\n<section class=\"description\">\n  <h2 id=\"description\">說明<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/operators/observeOn#description\"><i class=\"material-icons\">link</i></a></h2>\n  <p translation-result=\"on\"><span class=\"informal\">從 Observable 外部指定它使用某個特定的排程器。</span></p><p translation-origin=\"off\"><span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span></p>\n\n<p translation-result=\"on\"><code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> 是可以透過第一個引數指定排程器的運算子，此排程器將用於重新排程來源 Observable 傳送的通知。如果你無法控制給定 Observable 的內部排程器，但仍想控制其值的傳送時機，可以考慮使用此運算子。</p><p translation-origin=\"off\"><code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\nnotifications emitted by the source Observable. It might be useful, if you do not have control over\ninternal scheduler of a given Observable, but want to control when its values are emitted nevertheless.</p>\n\n<p translation-result=\"on\">回傳的 Observable 會發送與來源 Observable 相同的通知（下一個值、完成和出錯事件），但會改用提供的排程器重新排程。請注意，這並不意味著來源 Observables 內部排程器將以任何方式被替換。源仍然會被使用原來的排程器，但是當來源 Observable 發出通知時，它會立即再次排程一次，但這次會改用傳給 <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> 的排程器。這裡有個反模式是在會同步傳送大量值的 Observable 上呼叫 <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code>，並非同步將發出的值分成非同步區塊。這種情況下，排程器將被迫直接傳給來源 Observable（而正常情況下會傳給建立它的運算子）。<code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> 只會稍微延遲通知，以確保它們在預期的時機發出。</p><p translation-origin=\"off\">Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\nbut rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\nscheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\nnotification, it will be immediately scheduled again - this time with scheduler passed to <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code>.\nAn anti-pattern would be calling <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> on Observable that emits lots of values synchronously, to split\nthat emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\nObservable directly (usually into the operator that creates it). <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> simply delays notifications a\nlittle bit more, to ensure that they are emitted at expected moments.</p>\n\n<p translation-result=\"on\">事實上，<code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> 還能接受第二個引數，它以毫秒為單位指定將延遲多久傳送通知。<a href=\"api/operators/delay\"><code>delay</code></a> 運算子和 <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> 的主要區別在於 <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> 會延遲所有通知（包括錯誤通知）而 <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code> 會在來源 Observable 傳送錯誤通知時立即傳遞它。一般來說，強烈建議對流中的任何型別的值延遲使用 <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code> 運算子，而一般會用 <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> 來指定應該使用哪個排程器來發送通知。</p><p translation-origin=\"off\">As a matter of fact, <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> accepts second parameter, which specifies in milliseconds with what delay notifications\nwill be emitted. The main difference between <a href=\"api/operators/delay\"><code>delay</code></a> operator and <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> is that <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code>\nwill delay all notifications - including error notifications - while <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code> will pass through error\nfrom source Observable immediately when it is emitted. In general it is highly recommended to use <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code> operator\nfor any kind of delaying of values in the stream, while using <code><a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a></code> to specify which scheduler should be used\nfor notification emissions in general.</p>\n\n<h2 id=\"example\" translation-result=\"on\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/operators/observeOn#example\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"example\">Example<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/operators/observeOn#example\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">確保在瀏覽器重繪之前先呼叫 subscribe 中的值</p><p translation-origin=\"off\">Ensure values in subscribe are called just before browser repaint</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>, <a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a>, <a href=\"api/index/const/animationFrameScheduler\" class=\"code-anchor\">animationFrameScheduler</a> } <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> 'rxjs';\n\nconst someDiv = document.createElement('div');\nsomeDiv.style.cssText = 'width: 200px;background: #09c';\ndocument.body.appendChild(someDiv);\nconst intervals = <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>(10);      // Intervals are <a href=\"api/index/function/scheduled\" class=\"code-anchor\">scheduled</a>\n                                     // with async scheduler by default...\nintervals.pipe(\n  <a href=\"api/index/function/observeOn\" class=\"code-anchor\">observeOn</a>(<a href=\"api/index/const/animationFrameScheduler\" class=\"code-anchor\">animationFrameScheduler</a>) // ...but we will observe on <a href=\"api/index/const/animationFrame\" class=\"code-anchor\">animationFrame</a>\n)                                    // scheduler to ensure smooth animation.\n.subscribe(val => {\n  someDiv.style.height = val + 'px';\n});\n</code-example>\n\n</section>\n\n\n\n\n  \n\n  \n<section class=\"see-also\">\n  <h2 id=\"see-also\">參見<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/operators/observeOn#see-also\"><i class=\"material-icons\">link</i></a></h2>\n  <ul>\n  \n    <li><a href=\"api/operators/delay\"><code>delay</code></a>\n</li>\n  </ul>\n</section>\n\n\n\n  </div>\n</article>\n\n<!-- links to this doc:\n - api/operators\n-->\n<!-- links from this doc:\n - /api\n - api/index/const/animationFrame\n - api/index/const/animationFrameScheduler\n - api/index/function/delay\n - api/index/function/from\n - api/index/function/interval\n - api/index/function/observeOn\n - api/index/function/scheduled\n - api/index/interface/MonoTypeOperatorFunction\n - api/index/interface/SchedulerLike\n - api/operators\n - api/operators/delay\n - api/operators/observeOn#description\n - api/operators/observeOn#example\n - api/operators/observeOn#observeon\n - api/operators/observeOn#see-also\n - https://github.com/reactivex/rxjs/edit/master/src/internal/operators/observeOn.ts?message=docs(operators)%3A%20describe%20your%20change...#L6-L91\n - https://github.com/reactivex/rxjs/tree/7.5.2/src/internal/operators/observeOn.ts#L6-L91\n-->"
}